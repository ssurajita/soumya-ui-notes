Webpack 5
**********
Section 1: Introduction
Introduction
What you need for this course?
	//computer
	//javascript
	//html
	//browser
	//text editor
	//node.js
	//command line or terminal
	
Section 2: Intial Setup and integrating Webpack
Why webpack?
	//In earlier days typically the HTML page use to have several css and js files.
	//If we change the order of import accidentally the project might break. 
	//When I only started my career all the applications look like this.
	//But then we started to use grunt and gulp.
	//These tools helped us to manage assets and concatenate all of our javascript files into one.
	//But they still cant figure out the dependancies between those files.
	//in order to manage dependancies we used require.js which helps in a way. But it is not as powerful as webpack.
	//Webpack is a static module bundler for modern javascript applications
	//When webpack processes your application, it recursively builds a dependancy graph that includes every module in your application.
	//And then packages all of those modules into one or more modules.
	//When I started using webpack, most of my projects started to look like this.
	//In the html file we dont see any other css or html files. 
	//There are only 2 files - 1 file for css and 1 file for js
	//There are no hidden dependancies
	//You don't have to worry about the correct order of the files anymore
	//There is only one javascript file we need to include. 
	//All dependancies , internal, and external are bundled inside this file
	//Basically webpack is a single tool for managing all of your code as well as assets in 1 place.
	//It can handle js,typescript,coffeescript,css,sass,less,images and so much more!
	
	
	
Setting webpack in Our Application?
	Create a folder name it - TUTORIAL
	Create a file inside it - index.html
	create a folder src inside TUTORIAL
	create a file inside src - hello-world.js
	create another file index.js inside src

	TUTORIAL
		src
		  hello-world.js
		  index.js
		index.html

	index.html
	===========
	<!doctype html>
	<html>
		<head> 
			<title>Hello World</title>
			<meta charset='utf-8'>
		</head>
		<body>
			<script src='./src/index.js'></script>
			<script src='./src/hello-world.js'></script>
		</body>
	</html>


	
	hello-world.js
	================
	function helloWorld(){
		console.log("hello world")
	}
	
	index.js
	===========
	helloWorld()
	
	
	hello-world.js file we invoke this function from a different file index.js 
	In other words index.js file depends on hello-world.js file
	
	//let's have a look how it works in the browser.
	//I will open index.html in browser url and currently we have an empty page here.
	//But if we go to the develop tools and have a look at the console tab we will see a javascript error
	//Saying hello world is not defined at index.js
	//So why do we have this error?
	//So the issue is not with index.js file but with the HTML file (the 2 script tags)
	//Script we see index.js is included before hello-world.js
	//However it should be included after because inside the index.js you are using a function that's defined inside hello-world.js
	//Therefore the order of these lines is wrong.
	//Now lets change the order and refresh the browser again..
			<script src='./src/hello-world.js'></script>
			<script src='./src/index.js'></script>
	//We should see hello world in the console..
	
	
Install webpack and integrate it with NPM?
	//We are including only two JavaScript files inside, and we already have to reference them in the specific order 
		and we need to remember this order.
	//What if I had 20 JavaScript files or a hundred or JavaScript files maintained in such kind of a project
		would quickly become a nightmare.
	//For example, one of my latest projects has seventy five internal modules and around 20 external libraries.
	//luckily webpack can manage all those dependancies for us and conveniently bundle them into a single javascript bundle 
		that includes all the code needed for the application
	//Then we need to include these javascript bundle inside our html and this bundle will contain our dependancies.
	//Now you don't have to remember each module to include first, which to include second and so on.
	//webpack will sort that out for us..
	//By the way, it doesn't have to be a single JavaScript bundle containing all your application code.
	//Webpack can generate multiple bundles depending on your needs. 
	//We are going to cover different strategies for generating bundles later in this course.
	//so lets install webpack..
	//But before that, we need to generate a package.json, for our application, 
		the package.json keeps track of, all dependencies needed for the application.
	//In order to do that, we need to go to the terminal and run a simple command.
	//cd tutorial
	//npm init
	//This comment generates the default package that Jason, for our application.
	//Now I'm going to install Webpack
	//I am installing 2 packages here.
	//npm install webpack webpack-cli
	//And we are using --save-dev 
	//This option will add up back to the package.json file..as a development dependancy.
	//if somebody else would like to work on the same application, they can easily find all the dependencies for this application, 
		at least that inside the package.json.
	
Small Note about Github Repository
	//Hi guys and girls,
	//I hope you are enjoying the course so far!
	//I just want to let you know that there is a Github Repository containing all the code for this course. 
	//If you have any issues with the code, it will help you to resolve those issues and continue with the course.
	//I am explaining how you can use the Github Repository in Section 7.
	//If you have any questions regarding the course, please feel free to write me via Q&A section and I will do my best to help you!
	//Resources for this lecture
	//Github Repository - https://github.com/vp-online-courses/webpack-tutorial
	
Integrating webpack in our application?
	//In this video, we're going to run webback and see how it works.
	//However, before running the webpack, we need to make a couple of adjustments in our current code base.
	//first of all lets go to the HTML and remove one of the script hello-world.js file. We dont need it anymore..
	//In order for this to work, we need to explicitly import all the dependencies inside the javascript code
	//so lets go to index.js and import helloWorld()
	//So before using helloWorld() function we need to import it.
	//import helloWorld from './hello-world.js';
	//The dot in above import means that this path is relative to the files we are in..
	//We also need to explicitly export  helloWorld() function from helo-world.js
	
	index.js
	===========
	import helloWorld from './hello-world.js';
	helloWorld()
	
	hello-world.js
	================
	function helloWorld(){
		console.log("hello world")
	}
	export default helloWorld;
	
	
	//The syntax I'm using here is related to ECMAScript module's 
	//ECMAScript module's is the current standard for working with JavaScript modules, 
		and webapck supports ECMAScript modules by default.
	//Now lets go to the terminal and run webpack
	//npx webpack
	//From the output in the terminal, I can see that this comment has been successful here.
	//We just ran webpack without any configuration at all.	
	//Normally we would provide a configuration file for webpack.
	//However webpack5 and webpack4 uses the default configuration unless you provide a custom one.
	//Generally it's better to provide a custom configuration because it allows you to specify a lot of useful options.
	//And this way it's much more convenient to store and maintain your configurations.
	//You can also notice that webpack complains that the mode option has not been set.
	//mode is a special option for a webpack that makes it much easier to setup different configurations 
		for production and development use cases.
	//And we also see upon running npx webpack, one file was generated and this file is called main.js
	//lets explore this file and see what we have inside.
	//(()=>{"use strict";console.log("Hello World")})();
	//We can see that webpack has created an output folder for us, and this folder is called "DIST"
	//If you provide a custom configuration to webpack, we will be able to choose the name of the output folder.
		as well as many other things that we are going to explore later in this course.
	//Here you can see that main.js file contains the optimized version of our code at this point
	//at this point, I would ask myself how webpack figured out where to take this code from.
	//If I go back to the terminal, I can see that webpack Output says something about the entry point.
	//The entry point is a file which webpack uses as a starting point when building your application.
	//This file would usually import other modules from the application
	//here Webpack assumes that the entry point is a file called index.js, as that's located inside of the src folder.
	//Again, this is the default entry point and you can change that when you provide your own configuration to webpack
	//So in this video, we installed Valpak and seen the results of its work.
	//In the next video, we are going to create a custom configuration for webpack.
	
	
Custom configuration for webpack?
	//Lets create a custom configuraton for webpack
	//webpack.config.js(default file name)
	//We can also name it something else, but for time being lets keep the same default file name.
	//lets create a file webpack.config.js in the root folder of our application.
	//lets specify basic webpack configuration which is going to be very similar to the default one.
	//
	
	//webpack.config.js
	module.exports = {
		entry: './src/index.js',
		output: {
			filename: 'bundle.js',
			path: './dist'
		},
		mode: 'none'
	}

	//Webpack expects this module to export the configuration object 
	//inside this object we can specify many useful configuration options in this video.
	//We are going to touch only the most basic ones.
	//We are going to explore dozens of other options later in this course
	//So our first option is going to be an entry point, 
	  This file usually imports all other modules in your application that will start from this file when running the build process.
	//In our case it is index.js
	//The second option is an output file 
	//here we can specify name of the file which will be generated as a result of the build process and pass to the directory where this file should be generated
	//In our case this is bundle.js
	//And it will be generated inside the directory named dist
	//So after webpack runs , it will generate a file called bundle.js inside of folder called dist
	//Webpack will automatically creates this folder if it does not exist
	//And the last mandatory option is mode for now we will specify none here.
	//But later in this course, I will explain why we need this option and how to use it.
	//This is the minimal sensible configuration file, let's run webback and see if this works.
	//npx webpack
	//It turns out there is an error in our configuration, this error is quite popular, 
		and that's why I'm showing it in this video.
	
	//I hope if you encounter such an error unintentionally, you will know how to fix it.
	npx webpack
	[webpack-cli] Invalid configuration object. 
	Webpack has been initialized using a configuration object that does not match the API schema.
 	- configuration.output.path: The provided value "./dist" is not an absolute path!
   	-> The output directory as **absolute path** (required).
	
	//What this error means is that we specified a relative path in the output path configuration option,
	  but instead we needed to specify an absolute path.
	//lets fix that..
	//There is a this package that can help us to generate an absolute pass, let's import this package.	
	//Please note that here I'm using the old way of importing module's common js 
		because inside the configuration file, you can't use ECMAScript modules.
	//It was always like that. And it's still the case in webpack5.
	//So what I need to do now is I need to replace this relative path with an absolute path.
	
	const path = require('path')
	module.exports = {
  		entry: './src/index.js',
  		output: {
    		filename: 'bundle.js',
    		// path: './dist'
    		path: path.resolve(__dirname, './dist')
  		},
  		mode: 'none'
	}
	
	//path.resolve(), converts a sequence of path segments into an absolute path.
	//As the first argument, I will specify the current folder and the second argument, I will specify the relative path to the folder.
	//Let's run webback one more time and see if it picks up our configuration.
	//First, I will remove the existing dist folder that was generated during the previous run.
	//Now we are ready to run back again.
	//This time, everything went well. Let's take a look inside the dist folder.
	//As you can see, the name of the bundle differs from the default one, 
	//if you remember when we were back with no configuration, it generated a file called main.js.
	//But this time the name of this file is bundle.js as we specified in the configuration file.
	//This means that webpack no longer uses the default configuration.
	//Instead, it uses the custom configuration that we provided.
	//By the way, if I go to the HTML file index.html, I can see that we are referencing the wrong file in the script tag
	//At the moment, we are still referencing index.js.
	//But that's not the case anymore because what they actually need is a in bundle generated by webpack.	
	//Every time I run webpack, it generates JavaScript, bundle inside the dist folder.
	//And here I need to reference this bundle.
	  	<body>
    		<script src="./dist/bundle.js"></script>
		</body>
	//This is what we specified inside the configuration file.
	//Now, let's go to the browser and check if our application still works.

	file:///Users/soumyasurajita/Documents/udemy-courses/webpack-tutorial/index.html
	
	//And you can see the hello world message in the browser console.
	//As you can see, the application still works and now we are using code generated by webpack.
	//In order to run, Bapak, more conveniently, we can create a script inside package.json.
	//If I go to the package.json, I will see a list of scripts here.
	//By default there is only a test script which does nothing.
	//It was automatically generated when we created our package.json.
	//So I will add a new script here and I will call it build.
	//Every time we're on this script, it will run webpack for us.
	  "scripts": {
    		"test": "echo \"Error: no test specified\" && exit 1",
    		"build": "webpack"
  		},
	
	//So in this video, we created a custom configuration for this configuration is very similar to the default one 
		and it's not doing much at the moment.
	//In the next sections of this course, we're going to explore a lot of various configuration options that you can provide to webpack.
	
Section 3: Loaders	
What is webpack loader?
	//In this section we are going to learn about webpack loaders 
	//At this point you would ask what loaders are
	//webpack was designed to help you bundle all your dependencies into one single file.
	//What kind of dependencies are we talking about.
	//Usually dependencies are other javascript modules that your main JavaScript file requires in order to do its job.
	//But we can do more than that 
	//With webpack you can import css files right into your javascript code 
	  you can import sass less handlebars xmls and so much more.
	//There are a lot of things you can import using webpack 
	//And the webpack loaders are javascript libraries that help you import all that stuff.
	//In the next videos we are going to talk about various loaders that you most probably will use in your projects.
	
	
Handling images with Webpack?
	//In the previous video, I have told you that we can import lots of different stuff using webpack, 
	//so let's get crazy today and import an image.
	//Yes, webpack made it possible to import images right into your JavaScript code.
	//I have already placed an image inside a src folder.
	//This image is called kiwi.jpg.
	//Let's create a new JavaScript file where we will be adding that image to the DOM.
	//I will call this file add-image.js
	//Inside this file, I will create a function which will add an image to the DOM, I will call this function addImage().
	//Inside this function, I will create an image element, specify an alt width and src properties.
	//But what should I put inside the src property?
	//Now it's time to import our image.
	//Now, Kivi contains the public URL to the file, and we can simply assign it to the img.src.

	add-image.js
	*************
	import Kiwi from './kiwi.jpg';
	function addImage() {
  		const img = document.createElement('img');
  		img.alt = 'Kiwi';
  		img.width = 300;
  		img.src = Kiwi
	}
	
	export default addImage;
	
	//Let's add our newly created img element to the body dom element
	//Don't forget to export our function because we need to import it inside index.js.
	//Now let's go to index.js and import an image function there, 
	//I will add it right after I import helloWorld() function. 
	
	index.js
	*********
	import helloWorld from './hello-world.js';
	import addImage from './add-image.js';

	helloWorld();
	addImage();
	
	//Now we need to invoke addImage function.
	//The calling part is done, but webpack does doesn't know yet how to import this image.
	//We still need to teach you how to import image files.
	//We need to go to the fatback configuration file and add a special rule which will tell how to import image files.
	//Inside the webpack configuration file, you need to add a new property.
	//This property is called module and this is a JavaScript object
	//inside this object we will have another property called rules.
	//This property simply contains an array of specific rules, each rule is an object itself.
	//It has at least two properties.
	//First one is test.Here, I will write a regular expression.
	  This regular expression will match the png and jpg files it checks if the file name contains either .png or .jpg,
	//Second, property inside the rule object is called use.
	  Here you can specify which lorder should be used by webpack when it needs to import png or jpeg file.
	//In this case, we will use file order.
	//So every time we try to import a jpg file, webpack will check if it has a rule for it.
	//If it doesn't find a suitable rule, it will give an error, which means something like the following.
	//Hey, unfortunately, I don't know how to import this file.
	//Please tell me what I should do with it.
	//On the other hand, if it finds a role for this file, it will import as a file according to the rule.
	
	Module parse failed: Unexpected character 'ï¿½' (1:0)
	You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. 
	See https://webpack.js.org/concepts#loaders
	
	//Let's imagine we have more than one rule.
	//I will add one more rule to our configuration just for the purpose of this example.
	//Let's see how a webpack handles important of the new file, it's in the following way, I need to import a file called kiwi.jpg.
	//Do I know by heart how to import jpg files.
	//My comment here for some files, WETBACK knows how to import them by heart, even without any additional orders.
	//Example would be JavaScript files or json files.
	//You can import JavaScript files right away without additional configuration, but let's listen to webpack further
	//No, I don't know how to import JPEG files.
	//Let's have a look at my rules.
	//It seems I have two rules.
	//Let's have a look at the first one.
	//Is it applicable to JPEG files?
	//No, it's applicable to XML files.
	//And we have JPEG file here.
	//Let's have a look at the next rule.
	//Is it applicable to jpg files?
	//Well, it is applicable to jpg and png files.
	//Therefore this rule is applicable to jpg files.
	//So I will use this rule.
	//What does it tell me to do?
	//It tells me that I need to use file-lorder in order to import png and jpg file.
	//So I will do that.
	//I will use file loader.
	//There are many loaders that help webpack to import many different files.
	//You just need to know which law order you need and install it.
	//In this case, we are using file-loader which instructs webpack to copy the required file into the output folder.
	//By default the file name of the resulting file is the md5 of the contents of this file, which is the original extension.
	
	//Now I need to remove the first rule from here if you don't need it anymore.
	//It was needed just for the purpose of this demonstration and we need to install file loader.
	
	const path = require('path')
	module.exports = {
  		entry: './src/index.js',
  		output: {
    		filename: 'bundle.js',
    		// path: './dist'
    		path: path.resolve(__dirname, './dist')
  		},
  		mode: 'none',
  		module: {
    		rules: [
      			{
        			test: /\.(xml)$/,
        			use: [
          				'xml-loader',
        			]
      			},
      			{
        			test: /\.(png|svg|jpg|gif)$/,
         			use: [
           				'file-loader',
         			],
      			}
    		]
  		}
	}

	//So I will go to the terminal and right here npm install file-loader 
	npm install --save-dev file-loader
	//So file-loader is installed now and we can try to run webpack.
	//Our build is done, this is not enough yet, but we can go and check what we have in the browser right now.
	//I will refresh my page and for some reason, image is not there, so let's check the other parts.
	//Actually, image is rendered but src attribute is wrong, it just contains the name of the image which is now md5#.
	//However, ideally it should contain also the path to the image.
	//As we know, our image is located inside the folder.
	//So we need to specify this somewhere in the next video, you'll see how we can fix this.
	
	
Handling images with Webpack. How to use publicPath?
	//Now we need to tell webpack where it should look for our image
	//we can see that the image is inside the folder dist.
	//This file is actually our image.
	//It has a strange name because it is an md5#, but it's still our image.
	//Let's go to the webpack configuration and add one more property to the output configuration option.
	//This property is called publicPath.
	//I need to specify "dist/" here, because our image is located inside "dist" folder.
	//Don't forget the ending slash..
	
	//Now, let's run that back in the terminal and see if anything changes in the browser.
	//Our build is done, so I'm going to my browser and I will refresh the page.
	//now we can see our image on the page, and if I look into the developer tools, 
	I will see that our image begins with dist/ slash and then there is an md5#.
	//So basically publicPath tells webpack where all generated files are located
	
	//Let's assume that we deployed this website to the Internet and we have registered a domain http://the-most-awesome-website.com
	//So in order to correctly show images on this domain, we would need to change the publicPath to 'http://the-most-awesome-website.com/'
	//Let's play with it a bit.
	//So here instead of this, how you could do is...
	
	const path = require('path')
	module.exports = {
  		entry: './src/index.js',
  		output: {
    		filename: 'bundle.js',
    		// path: './dist'
    		path: path.resolve(__dirname, './dist'),
    		publicPath: 'dist/',
    		//publicPath: 'http://the-most-awesome-website.com/'
  		},
  		mode: 'none',
  		module: {
    		rules: [
      			{
        			test: /\.(xml)$/,
        			use: [
          				'xml-loader',
        			]
      			},
      			{
        			test: /\.(png|svg|jpg|gif)$/,
         			use: [
           				'file-loader',
         			],
      			}
    		]
  		}
	}
	
	//Because one webpack creates a path to the file, it will just concatenate these two strings, 
		so it will be the domain name and then slash and then file name.
	//Now let's go to the terminal and run our route.
	//Our build is done and we can go to the browser again and refresh the page, 
		and we cannot see the image here because I changed the publicPath.
	//But here inside the developer tools, we can see that our image starts with http://the-most-awesome-website.com/,
	and then comes the file name.
	//So in this video, we have successfully imported an image into the JavaScript file and became familiar with webpack loaders
	
	
	
Handling css with webpack?
	//One of the coolest features of webpack is the ability to import css files right into your JavaScript code
	//in this video we are going to learn how to do this.
	//Well, frankly speaking, we can import lots of different stuff into our JavaScript code, and we already seen how to import images.
	//So why is it so cool to import the CSS with modern component based frameworks like REACT or latest versions of ANGULAR?
	//It has become a best practice to separate your Web application into many isolated components.	
	//Each component has its own behavior described by JavaScript and its own styles described by CSS.
	//It's much better run components, styles and behavior are in the same place.
	//Then it's much easier to fix bugs add new features and reuse such components.
	//Let's refactor our hello-world.js file and make it a component.
	//It will be a button and when a user clicks on it, it will print hello world string to the browser console or on page body.
	//First, we need to create a folder called Components, and inside it create another folder called hello-world-button
	//Let's move our hello-world.js, file into the components folder and rename it to hello-world-button.js
	//I'm going to remove helloWorld function from here and instead create a class called HelloWorldButton.
	//This class will render a button 
	//When somebody clicks on the button, it will print Hello world text on the page right below that button.
	//I'm going to create a render() method inside this class.
	//This method will be responsible for rendering a button on the page 
	//inside the render method I will create a button dom element.
	//Now, I'm going to append this button to the body DOM element.
	//We need to export this component instead of the helloWorld() function.
	//Let's go to index.js and import our new shiny component here.
	//It's located inside the components folder and inside the hello-world-button folder.
	//Now I need to instantiate our component and we will call render() method.
	//Let's remove addImage() function for now.
	//I will also remove the import statement.
	//We also don't need that image file anymore.
	
	src/components/hello-world-button/hello-world-button.js
	*******************************************************
	import './hello-world-button.css';

	class HelloWorldButton {
  		render() {
    		const button = document.createElement('button');
    		button.onclick = function () {
      			const p = document.createElement('p');
      			p.innerHTML = 'Hello World';
      			p.classList.add('hello-world-text');
      			body.appendChild(p)
    		}
    		button.innerHTML = 'Hello World';
    		button.classList.add('hello-world-button');
    		const body = document.querySelector('body');
    		body.appendChild(button)
  		}
	}
	export default HelloWorldButton;

	//Now, let's get back in the terminal and check what we have in the browser.
	//I'm going to refresh my page and now there is no image anymore.
	//Instead, you have a button with the label Hello World.
	//However, this button doesn't do anything yet.
	//If I click on it, nothing happens.
	//Let's add some functionality to it.
	//I will go to the text editor and I'm going to add onclick property to our button.
	//When somebody clicks on it, it will create a paragraph element containing some text inside.
	//Now it's time to create some css.
	//I'm going to add some css glasses to the button and paragraph elements.
	//Now, let's create a css File and put it inside of the same folder as JavaScript file.
	//I'm going to put here some simple styles for the button element specifying padding, font size and colors.
	src/components/hello-world-button/hello-world-button.css
	.hello-world-button {
  		font-size: 20px;
  		padding: 7px 15px;
  		background: green;
  		color: white;
  		outline: none;
	}

	.hello-world-text {
  		color: green;
  		font-weight: bold;
	}
	
	//And I will also create similar styles for the paragraph element.
	//Now, we need to import this css inside our component.
	//This way, people usually organize their code in modern frontend frameworks like react or latest versions of angular 
	//Inside that folder named after our component in our case, this is HelloWorldButton.
	
	index.js
	*********
	import HelloWorldButton from './components/hello-world-button/hello-world-button.js'
	const helloWorldButton = new HelloWorldButton()
	helloWorldButton.render()

	//We have a JavaScript file, this behavior and css file these styles.
	//As you can guess, webpack doesn't know yet how to import css.
	//So let's teach them how to do it.
	//We need to go to the webpack configuration file and create a new rule there.
	//This rule is going to affect all css files.
	//And now I will specify not only one, but two loaders
		
	  {
        test: /\.css$/,
         use: [
           'style-loader', 'css-loader'
         ],
      }
	//As you can see, we can not only use different loaders with webpack, but we can also combine multiple loaders inside a single room.
	//This rule tells webpack that every time it tries to import a css file, it needs to use both css-loader and style-loader 
	//The css-loader, reads the contents of the css file and returns this contents.
	//But it doesn't do anything else with this css.
	//Then this style-loader takes the css and injects it into the page using style tags.
	//Thanks, by the way, using style-lorder bundles your css together into your JavaScript into a single result in a file called bundle.js 
	//In the future videos you'll see how to make them generated as separate files.
	//Now we have to install css-loader and style-loader.
	//Let's run webpack now and check what happens in the browser.
	//It seems everything is fine, so I will go to the browser and refresh my page and when I click on the button, I can see the green text.
	//So as you can see, our button became larger and greener than it was.
	//And when I click on it, green text appears.
	//It seems we have a lot of green here.
	//Let's go to the developer tools and check our head tag.
	//OK, so we have head tag here and we have a style tag here and inside the style tag there is our css.
	//So it seems everything works.Congratulations.
	//In this video, we have successfully imported css into our JavaScript code and learned how to combine multiple loaders inside a single room.

	npm i css-loader style-loader --save-dev
	
	
Handling SASS
**************
	//In the previous video, we learned how to import css right into our JavaScript code.
	//By the way, we can also write our styles using scss or less as well as other css preprocessors.
	//I will show you how to import scss in this course, but you can easily use anything you want in your application.
	//Let's change our css into scss.
	//First, I will change the file extension to scss and then I will use some variables for font size and color.
	//I will play a bit and change the color of the text to read.
	//Now, I can use these variables inside my css rules.
	//Don't forget to change the import statement on the JavaScript site.
	//Now we need to create a rule for scss files.
	//I will copy css rule and slightly modify it.
	//Now we need to add scss-loader to the end of the chain.
	//Pay attention to the order in which all orders appear in the array 
	//webpack process as loaders from right to left.
	//First, it will invoke scss loader which will convert our scss to css.
	//Then it will invoke  css-loader which will take that converted css and convert it to the JavaScript representation.
	//And only then webpack will invoke style-loader, which will create style tags inside our html page and put css into it, 
	//since we are using a new loader we have to install it.
	//I'm installing sass-loader as well as node-sass library
	//node-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass.
	//It allows you to compile files to assess files at incredible speed.
	//Now let's run webpack again and go to the browser and check if everything still works.
	//I will refresh my page now and make several clicks, and we have the red text here.
	//Yes, it still works. Congratulations.
	//In this video, we learned how to import css into our JavaScript code.
	//We also learned that we can combine multiple loaders inside a single rule.
	
	npm i sass-loader node-sass --save-dev
	
	
Using latest javascript features with Babel 7
**********************************************
	//In this video we are going to learn how to import the JavaScript files inside our JavaScript file.
	//What you would say I already know how to import JavaScript files.
	//You don't need any additional order for that.
	//And you're right.
	//We actually already did that.
	//We imported hello-world-button.js inside index.js and everything work out of the box so why do we need additional loader
	//javascript language is based on my script specification and this specification is evolving all the time. 
	//Every time the new version of my script specification comes out browsers go ahead and implement all the new features introduced in that version.
	//However it takes quite some time to implement all those features in every browser.
	//On the other hand you and me would like to use these new features right away.
	//We are not going to wait for a couple of years until all major browsers had support for those features.
	//So what should you do in this kind of situation.
	//Luckily there are special tools that can help you start using those features right away so you don't need to wait anymore.
	//These tools can convert modern javascript code into older javascript code that is already supported by all major browsers 
	//In this course we are going to use one of those very helpful tools the tool you are going to use is called Babel
	//Babel is the most popular javascript compiler it's used in almost every modern javascript application 
	//And in this video you will learn how you can use it together with webpack 
	//so let's go to the HelloWorldButton component we have a lot of hard coded things here.

	//Let's take css class of our button as an example and put it into a separate property.
	//Of course this won't make our code perfect but it's good enough for the purpose of this example.
	//I'll take this css class and create a class property here called buttonCssClass
	//And here in render() I'm going to reference this property so this is what is called class property and it's not supported by major browsers yet.
	//Most browsers only allow methods inside javascript classes but not properties like our buttonCssClass.
	//if I run webpack now it will throw an error as you can see webpack threw an error.

	hello-world-button.js
	*********************
	// import './hello-world-button.css';
	import './hello-world-button.scss';

	class HelloWorldButton {
  		buttonCssClass = 'hello-world-button'
  		render() {
    		const button = document.createElement('button');
    		button.onclick = function () {
      			const p = document.createElement('p');
      			p.innerHTML = 'Hello World';
      			p.classList.add('hello-world-text');
      			body.appendChild(p)
    		}
    		button.innerHTML = 'Hello World';
    		button.classList.add(this.buttonCssClass);
    		const body = document.querySelector('body');
    		body.appendChild(button)
  		}
	}

	export default HelloWorldButton;

	npx webpack
	ERROR in ./src/components/hello-world-button/hello-world-button.js 5:17
	Module parse failed: Unexpected token (5:17)
	You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
	| 
	| class HelloWorldButton {
	>   buttonCssClass = 'hello-world-button'
	|   render() {
	|     const button = document.createElement('button');
 	@ ./src/index.js 2:0-84 5:29-45


	//It also says you may need an appropriate loader to handle this file type and webpack is right 
	//even though class properties are not part of the official ecmascript specification you can still use them with webpack
	//We just need to use special loader for that which is called babel-loader
	//Let's create a new rule for JavaScript files inside our configuration.
	//I will go to the webpack configuration and create a new rule here.
	//This rule will be applicable to all JavaScript files except those located inside the node_modules folder.
	//I'll tell webpack to use babel-loader for these files.
	//We also need to specify a couple of extra options for babel-loader
	//As you will see in the moment we can specify extra options for any webpack loader.
	//Of course this loader should support those options 
	//first option is called presets.
	//We need a special Babel preset which is called env 
	//env preset compiles ecmascript 6 7 8 9 10 down to ecmascript 5
	//In other words env preset support the latest javascript standard defined in the latest ecmascript specification
	//As I already said earlier class properties are not part of the official script specification 
	//so we need a special Babel plugin to support this feature.
	//This babel plugin is called transform-class-properties.
	//If you want to use another modern javascript feature which is not supported by major browsers 
		yet you should find a babel plugin for that and add it to the list of plugins 
	//you can use as many Babel plugins as you want.
	//Now I need to install babel-core, babel-loader, babel-preset-env and babel-plugin-transform-class-properties babel plugin.
	//So I will go to the terminal and install all that stuff
	
		npm i @babel/core babel-loader @babel/preset-env babel-plugin-transform-class-properties --save-dev
	//if I run webpack now it will use Babel loader one important javascript files 
	//And if it happens that our application uses some of the cutting edge features that didn't make it to the current ecmascript
		specification that package will convert such code to the older javascript code which is well understood by all browsers 
	//this time our built works fine.
	//Let's go to the browser now and check if everything's still works as expected.
	
	//I've just refreshed my page and you can see that the page still works as before 
	//in this video really aren't how you can use the latest javascript features in our applications.
	//Even if these features can be included in the official ecmascript specification yet.
	
	
	
Section 4: PLugins
WHat is webpack plugin?
	//a plugin is a javascript library that adds functionality to the webpack itself.
	//Plugins can do everything that loaders cannot do.
	//We use loaders when we need to import different files 
	//when we need to import the css files we use css-loader 
	//when we need to import xml files we use xml-loader.
	//But what if we need to do something else then import new type of file
	//these plugins can do much more than that.
	//You can define the global constants across the whole application.
	//You can modify your in bundle so it consumes less space on disk and is faster to download.
	//You can generate other files besides bundle.js 
	//webpack itself utilizes the same plugin system that you can use in your configurations.
	//In the following years are going to have a look at some of the most popular plugins.
	//plugins can modify how the bundles themselves are created.
	//For ex, uglifyJsPlugin takes the bundle.js and minimizes the contents to decrease the bundle size.
	
	
Minification of the resulting webpack bundle
	//In this video, we are going to learn how to modify our JavaScript bundle.
	//But first, let's understand why we need to modify it overall.
	//We are striving for the best experience for our customers.
	//We want our websites delivered fast.
	//If our customers are using our website on mobile, then the website performance is crucial for them.
	//If we make the size of the JavaScript file smaller than the whole website will load faster.
	//What's more, it will consume less Internet traffic.
	//Now, let's have a look at our current bundle size, 
	//our panel now is inside dist folder and I right click on it and open it in the file manager 
		and here I can get more information about this file.
	//And here we can see that our file currently consumes 21 kilobytes of disk space.
	//Let's figure out how to make it smaller 
	//in order to make our bundle smaller I will need to add a special plugin into webpack 
	//this plug in is called Dirceu Plugin.
	//So lets add plugin and see if the bundle size changes
	//After that, I will go to Webpack config js file at the new section there, which is called plugins.
	//This is a JavaScript array you can put here as many as you want 
	//For now, I will put here only one plugin.
	
		plugins: [
			new TerserPlugin()
		]
		
	//Pay attention that I am creating a new instance of TerserPlugin() here
	//Now we need to import TerserPlugin() at the beginning of the file.
		const TerserPlugin = require('terser-webpack-plugin')
		
	//Since we're using a new plug in here, we need to install it, so I will go to my terminal and install this plugin.
		npm i terser-webpack-plugin --save-dev
	//All webpack plugins should be installed --save, -dev option to indicate that they are used as development dependencies.
	//webpack plugin is a development dependancy because we need only during the build process 
	//if we use --save option without -dev part, then it would be considered a production dependency.
	//Production dependencies are required when we publish our project to production servers, 
	//however, we dont need webpack plugins on production servers.
	//That's why it's a development dependency
	//Now lets run webpack and check the bundle size one more time
	//The build is done.
	//Let's go to the editor again and look how many kilobytes our bundle.js file consumes now.
	//So I will open it in the file manager and here I will look again in the information.
	//And here you can see that it now consumes only 7 kilobytes.
	//So you have just made our bundle size smaller.
	//As a side note, I would like to mention here that using "TerserPlugin" is a new way of Minify your javascript's bundles, 
	//Earlier webpack was using uglifyJsPlugin for the same purposes you can still use again uglifyPlugin and get the same results.
	//However, using TerserPlugin is the recommended way nowadays.
	
	
Extracting CSS into a separate bundle with mini-css-extract-plugin, Part 1
	//In this video, you're going to learn how to extract our css into a separate file.
	//This video consists of two parts.
	//This is part one.
	//Some time ago, we learned how to import css inside our JavaScript files.
	//We did it using css-loader and style-loader.
	//As you can see, all our styles are inside the style tag right here, 
	//even though this is fine for development purposes and this is not good for production.
	//Using this approach, all our styles are bundled together with our JavaScript code inside a single file called bundle.js, 
	//styles dynamically added to the document object model by JavaScript during runtime.
	//However, there is one problem with this approach 
	//Our bundle file will become very big after some time and files need more time to load.
	//What we can do here is extract all our css into a separate file that will be generated alongside our JavaScript bundle.
	//This way we will have two bundles instead of one.
	//Why is it better than having one bundle?
	//First, this will make the size of our JavaScript bundle much smaller, so it will be faster to download.
	//And second, this will allow us to load several files in parallel, make an overall experience even better
	//Let's do something with our styles.
	//We need to add a new plugin inside our webpack configuration.
	//The name of this plugin is MiniCssExtractPlugin()
	//So I'm going to get a new plug in to the list of plug ins.
	//This will extract our success into a separate file, and you can even specify the name of this file.
	//Now we need to modify our rules for css and sass in order to use this MiniCssExtractPlugin 
	//first, I will change the rules for css.
	//I need to replace style-loader with MiniCssExtractPlugin.loader
	//Now, I need to do the same for the sass.
	//We also need to import this plug in at the beginning of the file
	//Since we are using a new plugin here, we need to install it.
	//Now, let's run the build process and check if we get something new inside this folder.
	//As you can see here, one additional file inside the dist folder, and this file is called styles.css.
	//Now we need to include this file inside our HTML markup.
	//Let's check if everything works in the browser.
	//As you can see, our styles work as before.
	//However, now we don't have any styles inside our style tag.
	//Actually, there is no style tag at all.
	//Instead, the styles are inside an external file.

	const path = require('path');
	const TerserPlugin = require('terser-webpack-plugin');
	const  MiniCssExtractPlugin = require('mini-css-extract-plugin');

	module.exports = {
  		entry: './src/index.js',
  		output: {
    		filename: 'bundle.js',
    		// path: './dist'
    		path: path.resolve(__dirname, './dist'),
    		publicPath: 'dist/',
    		// publicPath: 'http://the-most-awesome-website.com/'
  		},
  		mode: 'none',
  		module: {
    		rules: [
      		{
        		test: /\.(xml)$/,
        		use: [
          			'xml-loader',
        		]
      		},
      		{
        		test: /\.(png|svg|jpg|gif)$/,
         		use: [
           			'file-loader',
         		],
      		},
      		{
        		test: /\.(css)$/,
         		use: [
           			MiniCssExtractPlugin.loader, 'css-loader'
         		],
      		},
      		{
        		test: /\.(scss)$/,
         		use: [
           			'style-loader', 'css-loader', 'sass-loader'
         		],
      		},
      		{
        		test: /\.(scss)$/,
         		use: [
          			MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'
         		],
      		},
      		{
        		test: /\.js$/,
        		exclude: /node_modules/,
         		use: {
           			loader: 'babel-loader',
           			options: {
             			presets :  [ '@babel/env' ],
             			plugins: ['transform-class-properties']
           			}
         		}
      		}
    		]
  		},
  		plugins: [
    		new TerserPlugin(),
    		new MiniCssExtractPlugin({
      			filename : 'styles.css', 
    		})
  		]
	}


	npm i mini-css-extract-plugin --save-dev
	
	<!DOCTYPE html>
	<html lang="en">
  		<head>
    		<meta charset="UTF-8" />
    		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    		<title>Webpack tutorial</title>
    		<link rel="stylesheet" href="./dist/styles.css" />
  		</head>
  		<body>
    		<script src="./dist/bundle.js"></script>
  		</body>
	</html>



Extracting CSS into a separate bundle with mini-css-extract-plugin, Part 2
	//So let's go to the text editor and look inside the generated styles.css.
	//Here is all our css from the whole application, 
	//currently, our application consists only of one component.
	//HelloWorldButton
	//Let's create another component with some styles and check if all of those css from those components goes into styles.css file 
	//We will create a component named Heading.
	//So now I will create a heading directory inside the components directory.
	//And inside this directory, I will create a new file heading.js.
	//Let's create a new class for our component.
	//This class will have only one method called render().
	//This method will create an H1 element and inserted into the body element.
	//I will put some text inside H1.
	//And I will add h1 element to the body.
	//Now we need to export this class.
	

		class Heading{
  			render() {
    			const h1 = document.createElement('h1');
				const body = document.querySelector('body');
    			h1.innerHTML = 'Webpack is awesome..';
    			body.appendChild(h1);
  			}
		}

		export default Heading;
		
	//OK, our new component is finished, and what I'd like to do now is import our styles at the top of the file.
	//We don't have any styles for this component yet, but we'll create them in a moment.
	//Let's create a new file for our styles.
	//I created this file inside the same directory as the JavaScript file.
	//This file will be very simple if you just set a color of h1 element.
	//I will put gray here, it will be enough for this example.
	//Now let's import our new component inside index.js.
	//We need to create an instance of the heading component and then call the render() method.
	//Let's run the build process and have a look at the dist folder.
	//I'm going back to my editor and open styles.css.
	//And here you can see that css for both our components is inside.
	//These styles correspond to the HelloWorldButton component, and these two lines correspond to the h1 Heading component.
	//In other words, MiniCssExtractPlugin, extracts all other styles from the application and puts them inside a single file under the folder.
	//Now let's check our application in the browser.
	//I refreshed my page in the browser and we got a new heading here which says Webpack is awesome, which is pretty much true in this video.
	//We learned how to extract our css into a separate file.
	//So let's go to the text editor and look inside the generated styles.css.
	//Here is all our css from the whole application

	
Browser caching
	//In this video, we are going to talk about browser caching and how that can help us with that 
	//this time we'll start with the theory before writing any code.
	//As you might know, every time you browser loads a website, it downloads all the assets required by this website.
	//Each website is different.
	//However, most of them require some JavaScript and css in order to work properly, and some websites require lots of JavaScript.
	//Each time the user reload the page, their browser downloads, all those files from the Internet.
	//This may become an issue, especially if your customers browse your Website using mobile devices with slow Internet connection.
	//Each time they go to a new page, they need to wait several minutes until the page is ready.
	//Fortunately, there is a solution to this problem, and it's called browser caching, 
	//if the file didn't change between the page reloads, your browser can save it in a specific place.
	//This place is called cache.
	//When you open this page again, browser wont download this file again.
	//It will take this file from cache.
	//This technique helps to save lots of time and traffic.
	//However, this may lead to another issue.
	//What if you fixed a bug on your website and your JavaScript file has been changed?
	//If the browser always takes this file from your cache the customers will never get the new version.
	//Therefore, we need a mechanism for updating the cache.
	//One of the most popular approaches is creating a new file with a new name Each time you make a change, 
	//browsers remember file by name.
	//Therefore, if the name changes, browsers will download the new version.
	//Well, it doesn't mean that we need to change the file name every time manually when we change our code.
	//We can do this automatically.
	//Let's go to the webpack configuration file.
	//One of the best practices is to add md5# to the name of the file 
	//this md5# depends on the contents of the file.
	//This way, webpack will generate the new file name only if there were some changes inside.
	//It's easy to explain by example.
	//Imagine you changed something in your css, but you didn't touch your JavaScript.
	//In this case, webpack will generate the new name for your css file, 
		but it will use the previous name for the JavaScript file and during the next page, reload.
		Your customers will download the new CSS.
	//They will get the JavaScript file from cache.
	//In order for this to work, we just need to add [contenthash] in square brackets for output file name.
	
		 output: {
    		filename: 'bundle.[contenthash].js',
    		// path: './dist'
    		path: path.resolve(__dirname, './dist'),
    		publicPath: 'dist/',
    		// publicPath: 'http://the-most-awesome-website.com/'
  		 },
	//So the output file name. bundle.[contenthash].js
	//Now, let's run webpack in the terminal and check the folder.
	//You see, you have two JavaScript files in the folder, 
	//one is bundle.js and another one is bundle. and some strange sequence of characters .js.
	//This sequence of characters is the hash and it stays the same if there were no changes.
	//Let's run webpack again and have a look at the dist folder one more time.
	//I just run webpack again and we still have the same JavaScript files in dist folder.
	//Let's now change something inside our JavaScript.
	//I have added only one line of code here.
	
		let ten = 10; //index.js
	//Let's run webpack again and have a look at the dist folder.
	//Now we have three JavaScript file in dist folder that's because of it generated in JavaScript file with
		different modified hash.
	//Now, let's remove this line of code.
	//It was needed for demonstration purposes.
	//By the way, this also works for css files, we just need to add contenthash in square brackets 
	//so the means css, MiniCssExtractPlugin configuration.
			  plugins: [
    			new TerserPlugin(),
    			new MiniCssExtractPlugin({
      				filename : 'styles.[contenthash].css', 
    			})
  			  ]
	//Let's run the webpack again and have a look at the dist folder.
	//Now, there is another css file in the dist folder, and this css file contains md5# as well.	
	
	
	
	
How to clean dist folder before generating new bundles
	//At the moment, our dist folder is quite cluttered.
	//And most of the files inside are redundant.
	//These are the leftovers from the previous builds 
	//That's because the names of our bundles contain md5#
	//This md5# is generated based on the contents of the file, 
	//Each time you change something inside any file, it's md5# changes as well.
	//That's why we are getting new bundles with every file change 
	//in this video. We'll see how we can remove all the bundles from the dist folder before generating the new bundles.
	//I bet you already guessed that has a plugin for that.
	//You're right.
	//And the name of this plugin is clean-webpack-plugin.
	
	//So let's add this plugin to the plugins array.
	//Each time you run the build process, CleanWebpackPlugin clean output, the path folder.
	//This is the output folder 
	//in our case dist is the folder, but what do I mean by cleaning every time here on CleanWebpackPlugin?
	//But that simply removes all the files from dist folder.
	//This way ensures that it has absolutely clean folder before putting anything else to.
	//We also need to import CleanWebpackPlugin in order to be able to use it.
	//Since we are using a new plugin here, we need to install it.
	//As you remember, our dist folder currently contains five different files inside.
	//So now let's run the build process.
	//And now the folder contains only two files.
	//That's because that plugin has removed other files from the dist folder.
	//By the way, it's possible to clean multiple folders with this plugin, 
	  you just need to provide a couple of options when Instantiating the plugins array.
	//Let's imagine you have one more folder generated by some other to where you store some additional css files.
	//I will create this folder now.
	//And inside the building folder, you have one css file. file1.css
	//And one subfolder. Another css file. file2.css
	//Let's configure webpack to clean this folder as well.
	tutorial/build/file1.css
	tutorial/build/subfolder/file2.css
	
	//cleanOnceBeforeBuild patterns remove old files before, webpack generate the new files, 
	//you can specify an array of the file patterns which you want to remove.
	//All patterns are related to the webpack output.path reference
	//In our case, this is the dist folder.
	//This means to remove all the files together with Subdirectories inside that folder, no matter how many
	nested levels there are.
	//This is how cleanOnceBeforeBuild patterns works by default if you don't modify it.

	const { CleanWebpackPlugin } = require('clean-webpack-plugin');

	 plugins: [
    	new TerserPlugin(),
    	new MiniCssExtractPlugin({
      		filename : 'styles.[contenthash].css', 
    	}),
    	// new CleanWebpackPlugin()
    	new CleanWebpackPlugin({
      	// cleanOnceBeforeBuild
      	cleanOnceBeforeBuildPatterns: [
        	'**/*',
        	path.join(process.cwd(), 'build/**/*')
      	]	
    	})
  	]
  
  
	//However, if you want to remove the files outside of the folder, you should specify an absolute path to the file patterns.
	//This will remove all the files together with some folders inside the folder.
	//Let's check how it works.
		npx webpack
	//I will go to the text editor.
	//And now you can see that the build folder is empty.
	//This means that webpack removed all the files together with Subdirectories from this folder.
	//So in this video, we learn how to use webbpack in order to keep the dist holder nice and clean.
	

	
Generating HTML files automatically during webpack build process
	//In the previous videos, we added md5# to our bundles and learn how to keep the dist folder nice and clean, 
	//but did you notice what happened to our html file?
	//Well, you're right, absolutely nothing.
	//So if I open it now in the browser, our application will be broken.
	//You see, there is an empty page here and there are two errors in the browser console.
	//Do you know why it's broken?
	//If I go to the HTML file, you'll see that the references to our bundles don't include the md5#.
	//This reference doesn't include the md5#, and this js reference as well does not include md5#.
	//So in order to fix our small website, we need to change this references, 
	//so now I don't just copy the file name from here and paste it here.
	//I will do the same with the css file.
	
		<!DOCTYPE html>
		<html lang="en">
  			<head>
    			<meta charset="UTF-8" />
    			<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    			<title>Webpack tutorial</title>
    			<!-- <script src="./src/index.js"></script>
    			<script src="./src/hello-world.js"></script> -->
    			<link rel="stylesheet" href="./dist/styles.67ef41122526e32d599a.css" />
  			</head>
  			<body>
    			<script src="./dist/bundle.2267070b5b88e7169a00.js"></script>
  			</body>
		</html>
	//Let's go to the browser and check if this fix at our website.
	//I will reload the page.
	//And now you see that our website works again.
	//So does this mean that we need to change the names of the files manually after every build?
	//Come on, we are in the 21st century.
	//Even dishers can be washed automatically if you put them into a dishwasher.
	//Of course, webpack has a special plugin that updates the names of the files during each build 
	//This plugin is called HtmlWebpackPlugin, and it can also create the default html file for us 
	//so we don't have to worry about that.
	//Let's go to the webpack configuration and add this HtmlWebpackPlugin into the list of plugins.
		const HtmlWebpackPlugin = require('html-webpack-plugin')

		  plugins: [
    		new TerserPlugin(),
    		new MiniCssExtractPlugin({
      			filename : 'styles.[contenthash].css', 
    		}),
    		// new CleanWebpackPlugin()
    		new CleanWebpackPlugin({
      		// cleanOnceBeforeBuild
      		cleanOnceBeforeBuildPatterns: [
        		'**/*',
        		path.join(process.cwd(), 'build/**/*')
      		]
    		}),
    		new HtmlWebpackPlugin()
  		]
  		
	//Now, let's import this plugin at the beginning of the file.
	//The only thing that's left is to install it.
		npm i html-webpack-plugin --save-dev
	//Well, let's run the build process and have a look at the dist folder	
	//I will go to the text editor and look inside the dist folder.
	//It looks like we have a new file inside the dist folder, and this file is called index.html, 
	//Webpack generated this file automatically when we run the build process.
	//This file looks pretty much the same as our own index.html, except that formatting is not so nice.
	//However, there is one more thing we need to adjust.
	//The path to our bundles still starts with the prefix dist.
	//Since our html file is also located inside dist folder as they bundles themselves, we don't need this prefix anymore, 
		so we need to remove this prefix.
	//Webpack generates this prefix according to the publicPath option.
	//And we can change this option right here in webpack.config, so instead of having 'dist/' in publicPah we will have to leave it empty.
		    publicPath: '',
	//Now, let's run through build process again. npx weback
	//I will go back to the text editor.
	//And open the index.html file.
	//And now I can see that there is no these prefix anymore.
	//As you can see now, we have two HTML files, 
	//one file is generated by the webpack and located at inside dist folder 
	//and another file is located in the root directory of our project that we created ourselves.
	//So let's remove this second file because we don't need it anymore.
	//We will only use the file generated by webpack.
	//Let's open this html file in the browser and check if everything works.
	//As you can see, everything still works, even though we are using HTML file that was generated automatically
	//in the next video, you'll know how to customize some stuff inside this HTML file.

	
Customizing generated HTML files
	//In the previous video, we learned how to generate the HTML file automatically during each build.
	//In this video, we are going to learn how to customize this file 
	//in particular we are going to pass custom options to it. 
	//if you look carefully at the generated file you'll notice that the webpack changed the page title 
	//Earlier the title was "Webpack tutorial", and now it is "Webpack App".
	//We want our title back and there is a way to get it back.
	//Let's go to the webpack configuration.
	//Here we can pass additional options, to the plugin, for example, we can specify a custom title?
	//Actually, we can customize more things, 
	//we can also specify the name of the generated file and provide additional meta tag.
	//Let's specify a custom file name.
	//By the way, we can also specify a subfolder here.
	//This tells to create a subfolder in the dist folder and put the html file inside dist subfolder, 
	//let's provide an additional meta tag.
	//This tells webpack to add a description to the page,
	//let's run the build process and check if anything changes. npx webpack
	//Let's go back to the text editor.
	//As you can see now, we have a subfolder inside dist folder and inside this subfolder, there is our HTML file.
	//It has our own title, which is Hello World and our own description, which is some description, 
	//let's leave the filename name as it was by default.
	//I will remove the filename from options.
	//There are more options you can customize, all these options are listed on the GitHub page of this blog.
	//If you scroll down, you will see the list of options you can customize.
	//This is a list of options.
	//It's quite long list.
	//By the way, you can even provide your own template for the html file.
	//This way you can fully customize how it looks in the next video.
	//You'll see how you can do it.


Integration with Handlebars
	//In this video, you're going to create our own template for generating html file.
	//First of all, we need to decide which template engine we are going to use.
	//There are plenty of template engines out there.
	//You can use pug, ejs, underscore, handlebars and so on, all of them will give you similar results.
	//Which one to use is just a matter of personal preference?
	//I like handlebars the most.
	//So in this course we are going to use handlebars.
	//Handlebars is a template engine for JavaScript that allows you to separate the business logic from presentation,
	//If you find yourself generate an html inside your JavaScript, then you probably need some kind of template engine.
	//Let's create our first handlebars template.
	//We are going to create this template inside the src folder.
	//hbs is an extension for handlebars templates.
	//I can copy the html markup from the generated html file and put it here.
	//Let's improve formatting it.
	//We also need to remove the references to the bundles.
	//Webpack will add this references automatically during the build process, 
	//The names of the generated files will be different each time because we are using md5# in the bundle name.
	//You can put everything you need inside of this file, but will use it as a template while generating the HTML file during the build process.
	//In our case, I will leave the template as it is, but I will change the title and description in order to use kind of variables.
	//This is the handlebars variable, we will assign this variable in the webpack configuration.
		<!DOCTYPE html>
		<html>

			<head>
  				<meta charset="utf-8">
  				<title>{{htmlWebpackPlugin.option.ttitles}}</title>
  				<meta name="viewport" content="{{htmlWebpackPlugin.option.description}}">
			</head>

			<body>
			</body>

		</html>
		
	//I will also put the handlebars variable inside of the title.
	//Now, let's tell webpack to use our template while generating HTML file.
	//I will go to the webpack configuration.
	
		    new HtmlWebpackPlugin({
      			title: 'Webpack Tutorial!',
      			// filename: 'subfolder/custome_filename.html',
      			template: 'src/index.hbs',
      			description : 'Some description'
    		})
	//And here I will pass a new option, which is called template.
	//Here I specify for the path to the file we just created
	//We also need to provide the description variable, it should be specified on the same level as title.
	//webpack will take handlebars variables from here and here.
	//Since we are using a new type of file here, hbs, we need to teach you how to handle this type of file.
	//We are going to use a new loader here, which is called handlebars-loader.
		{
        test: /\.hbs$/,
        use: [
          'handlebars-loader'
         ],
      }
	//And since we are using a new loader, we need to install it.
		npm i handlebars-loader --save-dev
		npm i handlebars --save-dev
	//We also need to install handlebars, package itself.
	//Let's run the build process and see what happens.
	//It seems everything works fine.
	//Let's go check the dist folder
	//We still have index.html, inside dist folder.
	//Let's look inside.
	//This time, webpack used our own template for generating this file.
		
		<!DOCTYPE html>
		<html>
		<head>
  			<meta charset="utf-8">
  			<title>Webpack Tutorial!</title>
  			<meta name="viewport" content="Some description">
			<link href="styles.67ef41122526e32d599a.css" rel="stylesheet">
		</head>
		<body>
			<script src="bundle.2267070b5b88e7169a00.js"></script>
		</body>
		</html>
	//Let's have a look at it in the browser.
	//It seems everything still works.
	//Congratulations.
	//In this video, we learned how to tell webpack to use our own template while generating HTML.
	
	
	
	
More Webpack Plugins
*********************
	//In the previous videos, we talked about webpack plugins.
	//First we have seen how we can make the results in JavaScript bundle take less space on dist.
	//This also improved the loading time of the whole application.
	//Then we extracted all our css into a separate css bundle.
	//Then we learned how we can generate HTML files during the build process.
	//We used only several plugins in this section, but you'll notice that it's quite easy to include a new plugin into your webpack configuration.
	//Here is the list of all official Webpack plugins, if you need to use a plugin from this list, just click on the link 
		and go to the respective plugin page 
	//in order to see how to configure this particular plugin for your project.
	//There are a lot of third party plugins not included in this list.
	//I wouldn't be surprised if somebody created a webpack plugin that can make you a coffee while you're waiting for the build to finish.
	
	
	
Section 5: Production vs Development builds

Introduction
*************
	//Usually production builds require a different setup than development builds. 
	//In production we want our website to be as fast as possible. 
	//And our bundles should be as small as possible.
	//On the other hand, during development we often want to see an additional information inside our javascript code.
	//Like for example source maps and other stuff.
	//In this section we will talk about differences between production and development builds, 
		and how to make our webpack configurations serve both use cases.
	
	

Mode
*******
	//In this video, we are going to talk about the mode option.
	//Remember, we have a special option called mode in our webpack configuration.
	//This option enables certain built in optimisations for production builds and development builds.
	//By the way, the mode option became available starting from webpack 4 
	//Earlier versions of webpack required much more configuration in order to get the same results.
	//In the beginning of this course, you have set this option to none.
	//This means that we don't want any kind of built in optimizations.
	//Now it's time to change the value of this option.
	//There are 3 possible values that we can put here none, development and production.
		 mode: 'development',
		  mode: 'production',
		   mode: 'none',
	//Let's set mode option to different values and compare what happens with our bundle.
	//Let's set it to production.
	//Production mode enables quite a long list of different plugins, including TerserPlugin, 
	//if you want to see the full list of plugins, you can go to the official webpack documentation.
		
	//Here you can find the full list of plugins.
	//The mode option also sets process.env.NODE_ENV variable to production.
	//We can use this variable in our code to check if we are in production mode or in development mode.
	//Let's go to index.js and see how it works.
	//I will add a little bit of code here that you'll check NODE_ENV variable.
	
		
	//If process.env.NODE_ENV variable equals to production, we will print production mode to the browser console.
	//On the other hand, if this variable equal to development, we print development mode to the browser console.
	//Production and development mode handle errors differently in order to see what I mean.
	//Let's make some intentional error.
	//We're going to invoke a method that does not exist.
		helloWorldButton.methodThatDoesNotExist()
		
		index.js
		---------
		import HelloWorldButton from './components/hello-world-button/hello-world-button.js'
		import Heading from './components/heading/heading.js';

		const heading = new Heading();
		heading.render();
		const helloWorldButton = new HelloWorldButton()
		helloWorldButton.render();

		if(process.env.NODE_ENV === 'production') {
  			console.log('production mode')
		} else if(process.env.NODE_ENV === 'development') {
		    console.log('development mode')
		}

		helloWorldButton.methodThatDoesNotExist()

	//Now we need to run our build in the terminal.
	//Let's go to the browser and look into the browser console.
	//I will copy of all parts to index.html and paste it into the browser navigation bar.
	//In the browser console, we can see that we are in production mode 
	//and that we have an error because our JavaScript code is bundled inside one file and minified, 
	  we just see that as this error comes somewhere from bundle.js line1.
	//If I click on that line, I will go to the minified JavaScript code.
	//It's very hard to understand anything here.
	//Now, let's change the mode option to development and run our build again.
	//So let's go to the browser and check the page one more time 
	//I refresh my page, and now we see that we are in development mode and that we have an error coming specifically from index.js at line16
	//If I click on that line, I will go to the readable version of our source files to that specific line.
	//And here I can see that I'm calling the method that does not exist.
	//This is already much better.
	//This works because development mode users source maps by default.
	//In this video, you have seen how you can use mode option for optimizing our production and development builds.
	
	
	https://webpack.js.org/plugins/
	
Managing webpack configuration for production and development use cases
************************************************************************
	//In the previous video, you've seen how you can use mode option in order to change webpack behavior for production and development builds
	//Here we changed the mode option in the webpack configuration to production and then to development.
	//Following this practice, we would need to set mode option to development while developing our application 
		and change it to production every time we want to deploy the application.
	//This is not very convenient.
	//In this video, I will show you how to manage effectively in different configurations for production and development builds.
	//In fact, this is quite easy.
	//We just need to create two separate configuration files, one file for production builds and another file for development builds.
	//This is extremely useful, taken into consideration that this config files have much more differences than just the mode option.
	//So I will rename our webpack.config.js to webpack.production.config.js 
	//and I will also create one more file webpack.dev.config.js
	//For now, I will copy everything from the production configuration into this file.
	//However, we need to adjust these configurations here, let's adjust our production configuration,
	//we need to set mode option to production.
	//We can safely remove TerserPlugin because in production mode, this plugin is included by default.
	//We also need to remove this plugin from imports.
	//Everything else in this file is suitable for production, so our production configuration looks fine.
	
	//Now let's go to the development configuration and remove everything that we don't need.
	//First, we need to make sure that the mode option is set to development.
	//We don't need contenthash in filename in development mode because we don't need browser caching during the development mode.
	//We can also remove TerserPlugin from plugins array because we don't need to modify our code during development.
	//Code minification is an extra step that takes time, 
	//it makes sense to modify the output files in production when we need to optimize the page load time in order to improve the customer experience.
	//However, during the development phase, we should optimize the performance of the build process in order to improve the developer experience.
	//Due to the same reason, we also don't need to extract all our css into a separate file during the development phase, 
	//it's mostly needed for production 
	//so we can safely remove MiniCssExtractPlugin from the plugins array.
	//We can safely use style loader instead.
	//All these changes should make the development build faster.
	//You won't notice any difference in the small application.
	//However, in larger applications, this difference will be significant.
	//Since we now have two configuration files instead of one, we should make it possible to run them separately.
	//This can be easily done using NPM scripts.
	//We should have two different NPM scripts, one for production and one for development.
	//Let's go to the package.json and specify two different scripts 
	//at the moment there is only one script here.
	//We are going to continue using the script for production purposes.
	//Now, I will create a new script that we can use for development purposes.

	//In this script, I will change the configuration file so it points to the development configuration.
	//Now, let's check how this script work.
	//First, I will run the production script.
	//Production script works fine, let's now check the development script.
	//Development script also works fine.
	//So in this video, we created two separate webpack configurations for production and development purposes.

Faster development with webpack devserver
******************************************
	//In the previous video, we created 2 separate webpack configurations for development and production build,
	//we needed because our development build have another set in production build in order to work faster while developing new features.
	//We want to spend as little time as we can waiting for our code to build.
	//Ideally, we want to see our changes in the browser instantly, even without green building stuff.
	//I have a good news for you guys and girls.
	//We can make it happen.
	//And in this video I will show you how.
	//We will need to install the webpack-dev-server npm package 
	//it provides all the things we need.
	//So we are going into the terminal now and installing webpack-dev-server.
		npm i webpack-dev-server --save-dev
	//Now we need to specify options for the webpack-dev-server, 
	//We can just go to our development config and add a couple of lines there.
	//I'm going to modify web-config.
	//And here I will add a new option called devServer.
	//This is an object, and inside we need to specify 3 options.
	//First one is contentBase.
	//And it should point to our folder as an absolute.
	//So I can copy the absolute path from here and paste it here.
	//the next option is index, and here we need to specify the name of the index file.
	//So in our case, it's index.html.
	//And these are the option will be port on which this Web server will be around.
	//I will put 9000 here.
	
	webpack.dev.config.js
	----------------------
	  devServer: {
    	contentBase: path.resolve(__dirname, './dist'),
    	index: 'index.html',
    	port: 9000
  	  },
	//Now we need to change our npm script for development build, 
	//so it will use webpack-dev-server 
	//I will go to the package.json and here I can see our development script.
	//So I will replace it with webpack dev server.
	//And at the end of this option, I will write my last --hot.
	
	package.json
	-------------
	  "scripts": {
    		"test": "echo \"Error: no test specified\" && exit 1",
    		"build": "webpack --config webpack.production.config.js",
    		"dev": "webpack serve --config webpack.dev.config.js --hot"
  	  },
  
	//And that's it.
	//Let's run our development, build and see what happens.
	//I will go to the terminal run npm run dev.
	//So the build is ready.
	//webpack said that project is happening at HTP, localhost 9000.

	npm run dev
	> webpack-tutorial@1.0.0 dev /Users/soumyasurajita/Documents/udemy-courses/webpack-tutorial
	> webpack serve --config webpack.dev.config.js --hot

	â¹ ï½¢wdsï½£: Project is running at http://localhost:9000/
	â¹ ï½¢wdsï½£: webpack output is served from undefined
	â¹ ï½¢wdsï½£: Content not from webpack is serv
	So I will open this up in the browser.

	//And here we have a vote, which I will now put my browser and my editor on the screen, side by side.
	//And now let's change something in the index.js.
	//I will create a second heading here, just copy this 2 lines.
		
	//And change the variable into heading2.
	//So, yeah, I have created a second heading heading2 now and the magic begins, 
	//I'm saving the file and you saw it, we got an updated version and our browser instantly.
	//We are running webpack in the terminal.
	//Pure magic.
	//We can do the same this with css.
	//She says, I will go to the Hello World button styles and change the color of the button.
	//I want to change button background color to red.
	//And I'm saving the file.
	//So, again, it works instantly in this video on how to get our changes in the browser without manually
		 running webpack and also have seen some magic.


Cleaning up a bit
*****************

	
	
Section 6: Multiple Page Applications
Introduction
**************
	//Until this moment we have used webpack in order to take all our modules and put them together into a single bundle.js file.
	//As a result this bundle.js contains all our javascript code.
	//This approach is widely used when there is a need to create a single page application.
	//But this is not the only usage of Webpack. 
	//In some projects we need to have more than one html page. 
	//Especially if these pages are rendered on the server side
	//Then most probably server sends different pages to the browser depending on the url that you write in the navigation bar.
	//Like for example if we go to our hello-world page, then we see our hello world button.
	//And if we go to a separate kiwi page, we'll see our Kiwi image.
	//Remember? we imported this image early at the beginning of this course.
	//By the way, this two pages may also have something in common.
	//For example lodash library.
	//Then we need to find out how to handle this common dependencies as well.
	//In this section we'll learn how to split our javascript code into multiple bundles 
		and create multiple html files for different pages of our website.


Creating KiwiImage component
*****************************
	//Let's imagine that our Website should consist of two pages.
	//One is a hello-world page which we already have.
	//And the second one is kiwi page which we have just seen in the previous video.
	//Our second page would need a new component which would add a kiwi image to the page. 
	//In this video we will create this component.
	//All it will do is just add our kiwi image to the body dom element.
	//We will create a new folder inside the components folder for our new component.
	//I will name this folder kiwi-image
	//And I will move the kiwi image that we already have to this new folder.
	//Now we need to create the component itself.
	//So I will create a new JavaScript file
	//I will also name it kiwi-image.js.
	//And inside this file we will create our KiwiImage component. 
	//So I will create a new class KiwiImage
	//And this class will have only one function inside which is render().
	//Inside this function we will create our image element and then add it to the body DOM element.
	//I will add src to this image element. It should be a path to our kiwi image.
	//For this we would need to import our image into this file.
	//And now I can use Kiwi as an src.
	//We would also put an alt attribute here.
	//And I will add a class , css class to this element, because we would need to do some styling.
	//Now we already have our image element.
	//What we need to do now is to add this element to the existing body DOM element of our page.
	//OK it seems we are done now.
	//We need to export our KiwiImage class from this file.
	//So later we can import it inside our new Page

	src/components/kiwi-image/kiwi-image.js
	---------------------------------------
	import Kiwi from './kiwi.jpg';
	import './kiwi-image.scss';
	
	class KiwiImage {
  		render() {
    		const img = document.createElement('img');
    		img.src = Kiwi;
    		img.alt = 'Kiwi';
    		img.classList.add('kiwi-image');

    		const bodyDomElement = document.querySelector('body');
    		bodyDomElement.appendChild(img)
  		}
	}
	export default KiwiImage

	//This component will also have some css.
	//So we will add it as well. 
	//Inside our KiwiImage folder I will create yet another file which will be called kiwi-image.scss.
	//And inside this file I will add some simple css to our image.
	//I will specify display block and I will specify some specific width for our component, so it wouldn't be very big.
	//Like for example 400 pixels and also I will put height auto.
	//Now we need to import this css file inside the main component file, so I will go to kiwi-image.js. 
	//And right below the importing our image i will import css as well.
	
	src/components/kiwi-image/kiwi-image.scss
	-----------------------------------------
	.kiwi-image {
  		display: block;
  		width: 400px;
  		height: auto;
	}

	//It seems our component is ready now. 
	//In the next video we will create a page that will use this component.

	
	
Code splitting in Webpack: Multiple JS and CSS bundles
*********************************************************
	//In this video we will learn how to create two separate javascript bundles instead of one. 
	//In our future videos we'll include the first javascript bundle on the hello-world page 
		and the second javascript bundle on kiwi page.
	//So let's create our second page.
	//We will reuse our KiwiImage component that we created in the previous video.
	//So now I will create a new script file for our kiwi page and I'll name it kiwi.js.
	//This Javascript file to present our second page, kiwi page.
	//It will look almost the same as the hello-world page, but instead with the KiwiImage component inside.
	//So let's create it.
	//First let's import heading, because on this page we will also have heading.

And now let's create an instance of our heading component and render it.

Besides heading

we also need our kiwi image component which we just created in the previous video.

So let's import it.

okay.

And now we need to instantiate it and to render it.

cool.

It seems this page is ready.

Let's also rename our existing index.js file into hello-world.js.

Now we have two different JavaScript files that basically represent two different entry points that

should be included inside two different html pages.

Let's tell webpack to create two separate javascript bundles out of these two files.

We need to go to

webpack.production config.js.

And here we need to change something in our entry.

Basically we'll split this one file into two files so what we need to do is to replace this string with

a javascript object. Inside this object we will have two properties.

First one would be hello world

and it will point to the hello world file.

And the second property would be named kiwi.

And it will point to our kiwi.js file that he just created.

Since we have two entry points instead of one,

now we need to specify somehow that their names should be different.

With current configuration both of them will be named bundle.js.

Of course they will have content hash inside but it would be nice if we name it something different

that bundle.js. For example,

hello-world.js and kiwi.js.

So for this we just need to replace this bundle with a [name]. Like this.

So webpack will just take the name of the property from the entry point configuration option and put it

here.

And for the second file it will take other property and put it here.

By the way we can do the same trick for css files.

We just need to go to the mini-css-extract-plugin configuration and change the file name to

something very similar.

So we will also use [name] there.

Let's go to our configuration and change... inside this string we will change styles to be [name].

So let's run webpack now and check what we get after that in our dist folder.

Let's go to the terminal

And run npm run build.

it seems our build is done.

Let's go to our editor now and have a look at our dist folder.

We see that now we have two different JavaScript files inside our dist folder. One is called hello-world..js

and another one called kiwi..js.

And we also have two different css files. In this video

we have learned how to split our code into multiple bundles.
	
	
	


Section 8 : Webpack Integration with Node and Express

Introduction
    //At this point we already have a configurations for both single page applications and multiple page applications
    //as a result of our wwebpack build we have html files with the assets included 
    //in the case of a single page application we have only one html file
    //in the case of a multiple page application we have several html files each file corresponds to a page on our website.
    //However usually people don't just put html files somewhere on the internet when they want to publish their Web site.
    //Well sometimes they do but in most cases people create some kind of a backend or a web server in order to serve the content to the users.
    //In this section we will learn how to create such a backend and use it for our application.
    //It doesn't matter which technology to use while creating such a backhand you can use nodejs,php, Python,Ruby, Java and any other technology of your choice.
    //In this course we will use nodejs and expressjs framework.
    //So let's get started.



Getting code for Single Page Application
    //As I said in the previous video, first we will integrate Express framework into a Single Page Application. 
    //We will use code from Section 5 as a starting point. You can get this code from the Github repository. Just follow 3 easy steps:
    1. First, you need to clone this repository to your computer.
        git clone https://github.com/vp-online-courses/webpack-tutorial.git
        cd webpack-tutorial
    2. Then checkout the branch integrating-express-js-into-a-single-page-application.
        git checkout -b integrating-express-js-into-a-single-page-application remotes/origin/integrating-express-js-into-a-single-page-application
    3. Finally, don't forget to reinstall project dependencies after switching to the new branch.
        rm -rf node_modules
        npm install
    //At this point you have all the files you need in order to integrate Express framework into a Single Page Application.



Integrating express into our application
    //In this video we'll integrate express.js into our single page application.
    //What we'll do now is create a simple web server using Node.js and Express.js framework.
    //which will show some dummy content in the browser whenever user loads our web application. 
    //Let's create a file called server.js inside our src folder.
    //In this file we'll put our backend code.
    //First we need to require Express.
    //Now we need to create an instance of an express.
    //I will call the variable app.
    //What we need to do now, is to create a route on which our application will react.
    //I will specify a simple home page route which is a slash. 
    //And as a second argument, I will specify a function.
    //And this function will be called every time an express application gets a request to this route.
    //Inside this function we will send some dummy content back to the browser.
    //We will use res variable which is an instance of response object, and call a method send on it.
    //We will pass some dummy content as an argument to this method.
    
        server.js
        ---------
        const express = require('express');
        const app = express();
        
        app.get('/', function(req,res) {
            res.send('Some dummy content');
        })
        
        app.listen(3000, function() {
            console.log('Application is running on  http://localhost:3000/')
        })
    //Now we need to start our server and make it listen for some port, 
    //so the application can actually be running and listening to incoming connections.
    //For this we will use our app instance and we will call a method listen here.
    //We need to specify a port on which this web application will be listening for new requests.
    //I will specify port 3000 and as a second argument we can specify a function. 
    //And this function will be invoked when the application starts.
    //We can output some information into the console when application starts.
    //So I will just write "Application is running on http://localhost:3000".
    //This will be enough.
    //What we need to do now is we need to install express.
    //So in the terminal I'm typing npm install express --save.
    //In order to conveniently run our server, let's add a new script our package.json. 
    //I'm going to the package.json and I'm looking here for the scripts. 
    //Here they are.
    //So I will just add the new script here. I will name it start.
        "start" : "node src/server.js"
        
    //And I'll simply write here something like 'node src/server.js'. 
    //This will start our server. Now let's run our new script into the terminal.
        npm start
    //And it says that our application is running on http://localhost:3000. 
    //Let's check it in the browser. 
    //I'm going to the browser and pasting this link http://localhost:3000. Yeah.
    //And now we have some dummy content in the browser.
    //It seems that our Express application works! 
    
    //In this video we have successfully created a simple backend using Node.js and express.js framework that displays some dummy content 
	when we visit our website in the browser. 
    //In the next video we will learn how to display our own html page instead of a plain text there.


Serving HTML pages via express
    //In the previous video we have successfully created a simple backend using Node.js and Express.js framework
    //that displays some dummy content when we visit our web page in the browser.
    //In this video we will modify our backend in order to display our own html page instead of a plain text there.
    //First we need to replace dummy content that we have now with our html page that we created before.
    //For this, we will read the contents of our html file into a string and then send this string to the browser.
    //Let's do it.
    //First we need to get an absolute path to our index.html.
    //For this we will use already familiar Node module which is called path.
    //We already used it before when we needed to specify an absolutepath to our output file in the webpack configuration. 
    //I will remove this for now and instead I will get the path to html file.
        const pathToHtmlFile = path.resolve(__driname,'../dist/index.html')
    //And here as a first argument we will specify __dirname, which is our current directory, 
    //and as a second argument will specify relative path to our index.html.
    //This path is relative to our current directory.
    //So now we need to import path node module at the beginning of the file.
    //We don't need to install it via the NPM because path is a built in module inside Node.js.
    //Now when we know path to the index.html, we need to read its contents into a variable. 
    //For this we will use another built in module which is called fs.
    //readFileSync() method reads the contents of the file synchronously and returns the content of the file.
    //As a first argument we will specify path to html file,
      and as a second argument we need to specify encoding which in our case is UTF-8.
    //This means that the contents of the file is stored in Unicode.
    //Now we need to send this content to the browser and we'll use already familiar method send() on the response object.
    //And we'll send content from html file.
    //Let's now rebuild our application and check what we have in the browser.
    //Now we need to start our application.
    //And I will open it in the browser.OK.
    //We got reference error.
    //"fs is not defined" because we forgot to import it.
    //Let's import it here. And now we need to rebuild our application again.
    //And start it. I'm going to the browser again, reload this page, and now we got nothing.
    //We've got an empty page here without any content.
    //Let's investigate why it doesn't work.
    //First, let's view the html source of our page.
    //Well the source of the page is html.
    //And if you look closely you will notice that it is our html.
    //Here is our bundle.js and here is our styles.css. 
    //So why do we have an empty page?
    //Let's go to the browser console.
    //It turns out that we have a bunch of errors.
    //Browser complains that it cannot load our css and JavaScript.
    //That's because we did not teach express how to load our css or JavaScript.
    //We just told express that every time it gets a request to the /home URL, which is this slash here,
        it needs to send the content of html file back to the browser. 
    //And express does it correctly. It sends html content back to a browser.
    //We have seen it right now.
    //But in that html there are links to css and JavaScript. 
    //And when Express gets a request for css file, it doesn't know what to do with this request.
    //We simply did not tell express yet what it should do when it gets a request to a css file. 
    //In the next video, we will teach express how to handle static files.


Handling CSS and JS via Express
    //In the previous video we learned how to display our own html page when we get a request to the home page url
    //But we did not teach express how to handle requests to static files like css.
    //Let us teach express how to handle static files now.
    //basically what we need to do is just send the contents of this css file back to the browser every time we get a request for this css file.
    //In fact we need to do that for all static files.
    //We have Javascript, css, images, fonts, and so on.
    //For this we will create a separate route specifically designed to handle static files.
    //As you remember, all our static files are located in the dist folder. 
    //And whenever we get a request for a static file, we will just take this file from our dist folder and send it back.
    //We will define a separate url for all our static files
    //And we will use express.static() method to serve static files.
    //We would need to specify an absolute path to our dist folder.
    //path.resolve(__dirname,'../dist'), and relative path to the dist folder.
    //Now all requests from urls that start with slash static will go directly to our dist folder.
    //What we need to do is to include /static in all our static files inside the index.html.
    //As you can see URLs to our javascript and css files don't include static yet 
    //but we don't need to add /static manually to all those links. 
    //We can just change the publicPath option inside our webpack configuration
    //and /static will be added automatically to all our generated assets.
    //So I'm going to our production configuration now. 
    //And here We just need to change publicpath. Let's now check our browser.
    //But before that you would need to rebuild our application.
    //It's done and now I need to start the application.
    //Let's go to the browser now and check what is there.
    //I am refreshing my page and now you see our application is working again.
    //If I click on the button, the red text appears. 
    //Great! Now webpack knows how to handle static files and our small Website works perfectly.
    //In this video we have learned how to handle static files via Express framework.



Getting code for Multiple Page Applications
    In the next video we will integrate Express framework into a Multiple Page Application. We will use code from Section 6 as a starting point. You can get this code from the Github repository. Just follow 3 easy steps:
    1. First, you need to clone this repository to your computer.
        git clone https://github.com/vp-online-courses/webpack-tutorial.git
        cd webpack-tutorial
    2. Then checkout the branch integrating-express-js-into-a-multiple-page-application.
        git checkout -b integrating-express-js-into-a-multiple-page-application remotes/origin/integrating-express-js-into-a-multiple-page-application
    3. Finally, don't forget to reinstall project dependencies after switching to the new branch.
    rm -rf node_modules
    npm install
    //At this point you have all the files you need in order to integrate Express framework into a Multiple Page Application.


Integrating expressjs into multiple page applications
    //In this video we will learn how to integrate express.js framework into a multiple page application.
    //It is very similar to what we did with a single page application.
    //But now we need to handle several pages. 
    //In this video we will be using code from the Section 6 where we created webpack configuration for a multiple page application. 
    //So don't be surprised when you see hello-world.js and kiwi.js here instead of index.js file.
    //Let's go through some of the files we'll use in this video.
    //First let's have a look at the hello-world.js.
    //You should be already familiar with this file.
    //The only thing here is that we need to remove the line about React.
    //We don't need this line anymore.
    //Now let's have a look at kiwi.js file.
    //We have the same line about React here, and we also don't need it here as well.
    //We also have server.js file. 
    //We will be using the same code as we did when we talked about single page applications. 
    //But now we need to handle two pages instead of one.
    //So we need to create two routes instead of one.
    //First I will change the URL of our existing route to be hello-world.
    //And I will also change the path to html file to relate to helloworld.html.
    //Now I will just copy this route and adjust it
	//First I will change the url to be /kiwi/ and then I will adjust our path to html file to point to the to kiwi.html page.
	//we have already installed express.js in the previous videos.
	//So here I'll skip this step and that's all we need to do.
	//Let's check now how it works in the browser.
	//But first let's build our application.
	//It was a typo there.
	//Now I need to start the application. npm start.
	//It says that application is running on port 3000.
	//So let's go to our browser. 
	//and I'll paste a URL in the navigation bar which will be
		http://localhost:3000/hello-world/
	//and now we get our hello world page here. 
	//And it works perfectly.
	//And if I change route to be /kiwi/,
	//it will go to our kiwi page.
	//It seems everything looks really good. 
	//In this video we have successfully learned how to handle multiple pages with Express framework.




Section 9: Module Federation
Creating 2 separate applications Part1
	//In this video, we are going to create two standalone applications that can be run separately.
	//This video turned out to be quite long, so I split it in two parts.
	//This is part one.
	//Remember, in one of the previous sections, we created multiple page application, these two pages, fHelloWorld page and Kiwi page.
	//These two pages were part of the same application and we could switch between them by changing the URL in the browser.
	//However, for the purposes of this section, we need to move these pages into separate applications.
	//These two applications would be located in different folders.
	//They would have different Webpack configurations as well as different dependencies listed inside package.json
	//In the future videos of this course we are going to setup module federation within these 2 applications
	//Iâm going to use multiple page version of the application as the starting point for this video.
	//If you want to repeat all the steps on your local computer, you would need to call on this repository.
	//And then switch to this branch.
	//Don't forget to run, npm install after you switch branches.
	//First of all, let's create a new folder and move all the files into that folder, 
	//Iâll call this folder hello-world
	//Now let's create another folder called kiwi for now, 
	//these folders will be almost identical so I can copy everything we have in our existing folder to the new one.
	//Now, we need to adjust these two applications at the moment, most of them contain exactly the same stuff, but they do not have to be the same.
	//Therefore, let's go to the first application, which is Hello World, and remove everything we don't need there.
	//First, I'm going to change webpack configuration for this application.
	//At the moment, there are two entry points here.
	//hello-world and kiwi.
	//However, this application will be responsible only for the Hello World page.
	//Therefore, we need to remove all references to Kiwi from this application.
	//Let's also remove kiwi.js as well as kiwi image component.
	//Since we are going to have two separate applications, they will be served on different ports.
	//Earlier we were using the same port for them, which is 9000.
	//But from now on, we are going to use different ports, 9001 for helloworld application and 9002 for Kiwi application.
	//We also need to change the name of the file here.
	//Now, let's have a look at the list of rules that we have, I bet we don't need some of them in this application.
	//This rule is used for importing image files and it's used by Kiwi image component 
	//since this application does not contain the image component anymore We can remove this rule.
	//We can also remove css rule because we are using sass everywhere.
	//It seems we have two instances of HTMLWebpackplugin at the moment, but we only need one of them in this application.
	//And here we don't need to specify chunks property anymore.
	//We are done with the development configuration.
	//Now, let's do absolutely the same with the production configuration.
	//First, I will update the entry point.
	//Now, let's remove the rule for images and the rule for css files.
	//We also don't need the second instance of webpack plugin.
	//And here we don't need to specify chunks anymore.
	//And now we are done with production configuration as well.
	//Now, let's adjust server.js file so that we can run this application in production mode.
	//This is the entry point for Express.js Framework.
	//The contents of this file should be already familiar to you. We created it.
	//When you are talking about multiple page applications, we need to make only a couple of adjustments in this file.
	//For instance, you can see that we have two routes here, one for HelloWorld Page and the other one for Kiwi page.
	//However, in this case, we only need one route.
	//Therefore, I am going to remove the second one.
	//And here I will change the URL so that it points to the root of the application.
	//We also need to change the port to something else so that they use different ports for hello world application and Kiwi application.OK.
	//It seems we are done with Hello World Application.
	//In the next video we are going to adjust the Kiwi application.

Creating 2 separate applications Part2
	//In the previous video, we moved Hello World Page to a separate folder and converted it to a standalone application.
	//This video, we are going to do the same for Kiwi application and make sure both applications work as expected.
	//So let's go to the Kiwi application in our editor.
	//I will close all the tabs related to hello world application.
	//We need to remove references to Hello World from here.
	//Let's also remove hello-world.js and HelloWorldButton component.
	//As I said before, we are going to use Port 9002 for Kiwi application.
	//We also need to change in the name of the file here.
	//Now, let's remove some of the rules from here that we don't need, 
	//for example, you don't need the rule for css because you are using sass in this application as well.
	//We also don't need this babel plugging in Kiwi application because we don't use class properties here.
	//It seems we have two instances of HTMLWebpackPlugin at the moment, but we only need one of them.
	//And here we don't need to specify chunks anymore.
	//Now, let's do the same with our production configuration.
	//First, I will update the entry point.
	//Now, let's remove the rule for css files.
	.//We also don't need a babel plugin here.
	//And we don't need the first instance of HTMLWebpackPlugin.
	//I will also remove the chunks property from here.
	//It seems we are done with production configuration as well.
	//Now let's adjust server.js file.
	//In this case, we also need only one route instead of two.
	//Here, I will also change the url so that it points to the root of the application.
	//The last thing we need to do is we need to change the port to 9000 to 9002.
	//And that's it at this moment.
	//Both our applications can be run separately.
	//Let's go to the terminal and check if they still work.
	//Now we have two folders inside, first, I will check helloworld application.
	//Don't forget to run NPM install after removing applications, two separate folders.
	//Let's run webpack and see if it works.
	//OK, it seems there are no errors in the terminal.
	//Let's not run the application and check how it looks in the browser.
	//It says that the application is running on Port 9001
	//Let's go to the browser and open this URL in the new tab.
	//It seems everything works as expected.
	//Let's now check the other application we have created.
	//Don't forget to run npm install here as well.
	//OK, let's run webpack.
	//It seems there are no errors in the terminal, 
	//let's run the application and check how it looks in the browser.
	//It says that the application is running on Port 9002.
	//Let's go to the browser and open this URL in the new tab.
	//This page still shows an image
 	//in the next video we are going to setup Module Federation.
	//So these two applications can share code between each other at runtime.




Setting up Module Federation
	//In this video, we are going to set up Module Federation, which is the new feature introduced in the webpack5
	//module federation, allows one application to dynamically load modules from another application at runtime.
	//Remember, in the previous video, we created two standalone applications that can be run separately. 
	//Helloworld application and Kiwi application.
	//We made these applications completely separate from each other so they can be developed independently by two different teams.
	//They have different dependencies and they can even be deployed separately.
	//In this video, we're going to take the button, which is defined in Helloworld application as an example and reuse it inside the Kiwi application.
	//First of all, I would like to mention that Module Federation is available in webpack, starting from version 5.
	//Therefore, if you are using earlier versions of webpack, you need to upgrade to webpack5 before using module federation.
	//Let me show how you can do it.
	//Basically, it's a matter of running one simple command in the terminal.
	//I want to execute this comment now because I already have five installed.
	//Let's go to webpack configuration and set up a module Federation plugin.
	//Yes, there is a special plug in for that and it's available out of the box.
	//You don't have to explicitly install this plugin.
	//Let's configure module federation plugin in a way that other applications can use hello world button component in their code.
	//I need to include this plugin to the list of plugins.
	//This plugin accepts a variety of options.
	//First of all, let's give a name to our application.
	//During the build process, Webpack will generate a file that contains everything, this application export to the outer world so that other applications can use that.
	//Here we can give the name to this generated file 
	//by convention People use remoteEntry.js as the file name.
	//In the next option, we can list modules that will be exposed by this application.
	//Here we can specify the name of the module we expose.
	//As well as the path to this module.
	//Please note that all other applications will be referenced in this application using the public url
	//and this public URL is baked into a remote entry file and we need to make sure it is correct 
	//during the build process webpack doesn't know where we are going to deploy our application.
	//Generally speaking, I can build my application on my local machine and then take the generated files and copy them to some sort of CDN.
	//There is no way for webpack to magically know the public url of that cdn
	//And therefore we need to somehow tell webpack which url we are going to use.
	//There is already an option in the configuration file that we can use for this purposes.
	//This option is called publicPath.
	//Let's change our  publicPathto the correct URL.
	//We are going to run helloworld application on a localhost post, 9001.
	//We also need to put module federation plugin in the production configuration file.
	//Don't forget to import this plugin at the top of the file and change the publicPath.
	//We also need to make a small adjustment in our server.js file 
	//up to this point, we are serving static files from a separate URL called /static, 
	//if you no longer want to do that, I'm going to change this to a single slash.
	//Now, when we are done with HelloWorld Application, let's go to Kiwi application.
	//Here we also need to configure module federation plugin in order to be able to consume hello world button component.
	//This configuration will be slightly different from the previous one.
	//First of all, let's import module Federation plugin.
	//Now, let's add this plugin to the list of plugins.
	//Similar to the previous configuration here, we can give a name to our application.
	//Since this application does not expose any modules, we do not have to specify exposes option here.
	//Instead, we will specify the list of remote modules shared by other applications that we are going to consume here, 
	//to be more precise we will specify the list of remote applications and not a remote modules, 
	//for instance here we are specifying that we are going to consume some modules from HelloWorld application, 
	//but we don't explicitly list the name of the modules we are going to consume.
	//Now we need to specify the url where hello world application is deployed.
	//This is the name of the file you specified before on configuring hello world application.
	//Now we need to do the same in this production configuration.
	//Don't forget to import module federation plugin at the top of the file.
	//That's all we need to know in terms of webpack configuration 
	//now we can consume our button in the codebase.

Consuming federated modules
	//Now we can consume our button in the codebase.
	//Let's go to the Kiwi.js file and import hello world button there.
	//We need to use dynamic import because remote bundles are loaded asynchronously.
	//This is the name of the application we specified before.
	//This is the name of the component that hello world application exposes to the outer world.
	//We import the whole module here.
	//Since we used the default export when defining the HelloWorldButton component, we need to get that default export.
	//Now we can use HelloWorldButton component as if it was defined in this application.
	//Believe it or not, here we are using a component that defined in another application
	 and it's not even listed as a dependency in the package.json, this button is loaded dynamically at runtime and that's it.
	//Module Federation should work now.
	//Let's check it in action.
	//I will open two taps because we need to run two applications at once.
	//Let's go to the browser and check what we have there.
	//This is our HelloWorld application.
	//Now let's also run the Kiwi application.
	//And this is our Kiwi application, as you can see now, there is a button under the Kiwi imag 
	//this button is taken from the Hello World application and render it inside Kiwi application.
	//Let's check what we have in the developer tools.
	//You see, here is a remote file named remote entry that's loaded from localhost 9001,
	//believe it or not, on this page, we are rendering a component that we defined in a separate application which is deployed in a different url.


Modules are loaded at runtime
	//In the previous video, we successfully setup Module Federation for our applications.
	//We've seen how you can consume a component taken from another application without adding it as a dependency to the package.json 
	//in this video I will show you another huge benefit of the module federation.
	//First of all, let's make sure that both our applications are running.
	//OK, now both our applications are running.
	//Suppose I want to change this button according to the new business requirements 
	//in our case, let's assume that we need to change the color of the button.
	//Currently, this button has a green background and we need to change it to the blue one.
	//Let's go to HelloWorld application and adjust the styles of the button.
	//And here I can change the button background color.
	//Let's rebuild Hello world application in order to apply the changes.
	//Let's go to the brother and confirm that the color of the button has changed, I refresh to the page
	//as you can see, our button is blue.
	//Now, let's open the application in the browser and check if anything, in there.
	//Let me refresh the page.
	//You see what happened here?
	//The button became blue on this page as well.
	//However, we haven't changed a single line of code in Kiwi application.
	//The only thing we changed was this piece of styling inside Helloworld application.
	//I didn't have to change anything inside the Kiwi application.
	//I even didn't have to restart of this application.
	//That's because Module Federation loaded this button dynamically at runtime.
	//It will always take the latest up to date version of this button.
	//That's another huge benefit of the module federation feature in webpack5.

Section 10: Integration With jQuery

Getting the SourceCode
//In this section (and in the next sections as well) you would need to use Github repository associated with this course.
//We'll use the source code from starting-point-for-use-cases branch as a starting point.
//Let me show you how you can get the source code:
1. First, you need to clone the Github repository
	git clone https://github.com/vp-online-courses/webpack-tutorial.git
	cd webpack-tutorial
2.Second, you need to checkout the branch starting-point-for-use-cases.
	git checkout -b starting-point-for-use-cases remotes/origin/starting-point-for-use-cases
3. Finally, you need to install the project dependencies after switching to the new branch.
	m -rf node_modules
	npm install

Now you are ready to start with this section.
P. S. You would need to repeat these steps every time you start one of the following sections:
1. Integration with jQuery.
2. Integration with Bootstrap.
3. Using FontAwesome with Webpack.
4. Using ESLint.

Integration With jQuery
	//In this video I'm going to integrate jQuery into webpack.	
	//For those of you who never use jQuery this is a fast small and feature reached javascript library.
	//It can make a lot of things much simpler.
	//For example things like DOM manipulation, event handling, animation etc..
	//What's more it works in each and every browser I know
	//you can learn more about Jake worry if you go to the website jQuery.com
	//let's not have a look at our current application.
	//We have a single page application with the heading and a button. Hello world.
	//If I click on the button it displays some text underneath.
	//So far we have created everything here using vanilla javascript
 	//in this video I would like to rewrite the heading component using jQuery and then we can compare these 2 versions
	//first version using when you like Javascript and the second version using J query.
	//First I need to install Jacquard.
	//There is a possibility to install jQuery as NPM package
	//now jQuery is installed.
	//I am using âsave option because jQuery is a production dependency.
	//Now when we have jQuery installed let's import it 
	//I will go to the heading component because I want to rewrite this component using jQuery
	//so no I will import jQuery at the top of the file.
	//Now we have dollar variable imported from jQuery library.
	//Let's modify the heading component in order to use jQuery instead of vanilla Javascript 
	//so here you go using document.createElement() which is when you vanilla Javascript 
	//and I will write it to dollar sign and here we will specify html tag h1 
	//and these basically is doing the same as document.createElement() but it returns jQuery object here.
	//So now we need to rewrite the second line which is document.querySelector() 
	//and these I can also replace with a dollar sign but without this angular brackets 
	//so these will search and find a body DOM element inside our page.
	//Now let's go to the next line.
	//And here we have h1.innerHTML and these we can rewrite in jQuery as well.
	//So h1 is a jQuery object now and this object has text() method 
	//so I can write here text() this is a method and inside I will pass on our string.
	//And the last line can also be rewritten.
	//body is jQuery object and it has a similar method to appendChild() 
	//what it is called append() and it basically does absolutely the same as a appendChild()
	//It seems we are done for now.
	//Let's have a look at our code.
	//It looks more concise now but still works the same way as before.
	//Is it better than before.
	//For some people yes for some people no.
	//There are pros and cons in each approach 
	//use jQuery You can write less code and it looks more concise.
	//On the other hand you need to include jQuery in your javascript bundle and this means additional 85 kilobytes
	//another benefit of jQuery is that there are tons of jQuery plugins on the internet which can do everything you can imagine.
	//If you want to use any of these plugins you must have jQuery installed.
	//Now let's run webback and check our page in the browser.
	//As you can see our page still works the same way it is before but now we are using jQuery.



Section 11: Using Custom fonts with Webpack 
	//In this video you're going to learn how to use custom font with webpack.
	//Iâm going to use the single page version of the application as a starting point for this video.
		starting-point-for-use-cases
	//If you want to repeat all the steps on your local computer you would need to clone this repository
	//and then switch to this branch.
	//Don't forget to run npm install after you switch branches.
	//Currently we are using default fonts for everything on this page.
	//Often times web applications look much better when they utilize custom fonts instead of the default ones.
	//Iâm going to overwrite is a default font which sound more appealing to the users
	//The first link on the Google results page is the right one
		google fonts open sans
	//on this page you can see how this font looks like 
	//you can even type here your own text.
	//Now I need to download this font and put it inside my application.
		Select this font => download
	//unzip it
	//These are the files containing my custom font.
	//I don't need all of the variations for my application.
	//I will need only three of them.
	//As you can see all of the files use the .ttf format.
	//I want to provide a couple of more formats to my customers.
	//There is a website which you can use in order to convert your font to other formats as well.
		onlinefontconverter.com
	//Here I can choose which formats I need now.
	//I can drag my font files from my computer.
	//Next Iâm going to click on the Done button and wait until my font is converted to all of the formats I need
	//it seems the conversion is done.
	//Let's download the converted files
	//here we have one variation of our font in three different formats.
	//Let's move these files into our application.
	//I need to create a folder fonts where I'm going to store this fonts
	//Now I can move the a custom font files into this folder
	//next Let's use this font inside is application.
	//Iâm going to make it as a default font for all elements on the page
	//I will create another scss file that will affect the whole application
	//in order to tell the browser that we are going to use a custom font we need to use fontface css rule 
	//The fontface css rule specifies a custom font with which to display the text by allowing authors to provide their own fonts 
`	font face makes it possible to design content without being limited to the so-called Web safe fonts
	//websafe fonts are the fonts which are so common that they consider it to be universally available.
	//First I need to specify the font family.
	//This would be the name I can use later in order to apply this custom font to various DOM elements.
	//Now I'm going to specify the font weight for this custom font.
	//We have three variations of the same open Sans font but they have different font weight.
	//This property will help us to distinguish between multiple font variations.
	//Now we need to specify the location of the files that stores a custom font.
	//Iâm going to provide three formats in order to increase browser support
	//At the moment you specified only one font face 
	//These font face declares the light font which has font weight 300.
	//Now I need to specify two more font faces in order to cover two other font variations.
	//This one will cover font weight 400
	//and this one will cover font weight 600
	//Now I need to specify our custom font as the default font
	//The default font it will be 300.
	//Now I need to import this file before any other files in this application
	//There is only one thing left before we are done.
	//We need to configure webpack so it can understand font files.
	//I will go to the webpack configuration file 
	//in order to load fonts I need to add an extra rule to the webpack configuration
	//we need to support at least three formats for storing funds.
	//We are going to use a file-loader in order to import fonts into the project. 
	//This will preserve the file name and extension when generating files in the dist folder.
	//This will create a sub folder named fonts inside the dist folder.
	//I changed the development of webpack configuration.
	//Now let's add the same rule to the production configuration.
	//Make sure you have the file loader installed.
	//If you followed all the videos you should have it already installed on your computer
	//in case you don't you just need to run one simple command from terminal
	//that's all.
	//Now let's go to the browser and check if this actually works.
	//As you can see everything works 
	//All the text on the page is rendered using the custom font we provided.
	//So in this video you have seen how you can use custom fonts with Webpack.




Section 12: Integration with bootstrap
Using Bootstrap with webpack
	//Quite often we need to create Web applications completely from scratch 
	and we have to create all of the components by ourselves.
	//But it is not always the case.
	//Sometimes we can use already existing libraries.
	//This video is about one of the most popular front end component libraries in the world.
	//Bootstrap. 
	//To be more precise, this video is about how to use bootstrap together with webpack.
	//For those of you who never used bootstrap it is an open source toolkit for developing with HTML, CSS, and JavaScript.
	//It allows you to build responsive mobile first projects or quickly create prototypes for your ideas.
	//It includes responsive grid system, extensive prebuild components and powerful plugins built on jQuery.
	//You can learn more about bootstrap on its official website getbootstrap.com.
	//First let's have a look at our current project.
	//We have a single page application with a heading and a button "hello world". 
	//When we click on the button, it shows the text "Hello world" below.
	//We'd like to include some bootstrap components on this page.
	//First we need to install bootstrap.
	//There is a possibility to install bootstrap as an NPM package and include it inside our package.json.
	//So I am going into my terminal and type in npm install bootstrap --save. 
	//We are using --save option here because we need bootstrap to be included in the resulting bundle.
	//If we used --save-dev option, then bootstrap would be also installed inside node modules as a project dependency, 
		but it would not be included in the resulting bundle. 
	//Bootstrap depends on jQuery and proper.js.
	//So we need to install these libraries as well.
	//Now when we have bootstrap installed, let's include it inside our index.js file.
	//I am going to my editor. index.js, and what we need to do here is import bootstrap.
	//This way we include javascript from bootstrap.
	//We also need to include css. 
	//There are actually 2 ways to include css from bootstrap into our project.
	//First option is to import precompiled sass.
	//This option allows you to customize bootstrap to your needs and use the source files as part of your project's bundling process.
	//This option requires a bit of additional work in order to set up. 
	//Second option is to import already compiled ready to use css.
	//It is the easy option and we will use it in this video.
	//So let's import our ready to use css from bootstrap.
	//Now Let's go to our page template and add a couple of bootstrap components on our page.
	//I will add an alert and a dropdown.
	//First let's add an alert.
	//I will add it inside the body tag. 
	//And now let's add a dropdown as well.
	//I would like to add some simple styling to our dropdown.
	//Therefore I will put a custom class on it.
	//Now let's add some styles for our dropdown.
	//We'll create an SCSS file for our index page and call it index.scss
	//It will contain some simple positioning styles.
	//So here I am specifying my dropdown class and these are simple styles. 
	//Let's import our styles inside the index.js file.
	//Now it seems everything is ready.
	 //Lets run npm run build in the terminal and check what we have in the browser.
	//I am going to the terminal.
	//Here we can run npm run build.
	//Let's wait a couple of seconds.
	//It seems our build is ready.
	//Now let's start our application.
	//It says application is running in port 3000. 
	//Now let's go to our browser and check it. 
	//I will refresh my page.
	//And here we see our page with the alert from bootstrap here and with a dropdown component from bootstrap.
	//And if we click on our dropdown component, we can see some dropdown items inside. 
	//So in this video we have learned how to use bootstrap together with webpack.



Second Method of importing CSS from Bootstrap
	//In the previous video we have learnt how to use bootstrap together with webpack.
	//We learned that there are two ways to include css from bootstrap into our project. 
	//We can either import pre-compiled sass or import compiled and ready-to-use css. 
	//In the previous video we imported ready-to-use css.
	//So in this video I will show you how to import precompiled sass.
	//This method allows you to customize bootstrap to your needs and use the bootstrap source files as part of the bundling process.
	//However, for this option to work, we need to modify our rule for scss files and install a couple of conditional loaders.
	//So let's go to webpack.production.config.js and do it.
	//So now we are inside webpack configuration. 
	//And we need to modify this rule which relates to SCSS files.
	//I will align a little bit this loaders.
	//And now we need to add an additional loader to our rule. 
	//This loader is called postcss-loader and we will put it between css-loader and sass-loader.
	//Here is how it looks like.
	//postcss-loader lets you convert modern CSS into something that most browsers can understand.
	//We can provide various plugins to postcss loader. 
	//autoprefixer is a postcss plugin that allows to parse CSS and add vendor prefixes to CSS rules.
	//precss is a postcss-plugin that lets you use latest CSS features like color functions, logical and custom properties, 
		media query ranges, and image sets right now. 
	//So now we need to install postcss-loader together with autoprefixer and precss. 
	//Iâm going to my terminal.
	//And now I need to install these things.
	//Now we need to include sass files from Bootstrap inside our index.scss file.
	//And going to my editor to the index.scss file.
	//And here right at the beginning of the file I will include the bootstrap files.
	//Yeah After this is done we can go to that index.js
	//And right here we don't need this line anymore, so we can simply remove it. 
	//We used this line when we imported ready-to-use css in the previous video.
	//We still need these lines though, because they... the first line imports javascript from Bootstrap,
	//and this line imports our index.scss file. 
	//Let's go to the terminal and run our webpack build.
	//Our build is done and let's start the application.
	//Application is running.
	//So now we can go to our browser and check what we have there.
	//I will refresh my page.
	//And now we can see that we still have a bootstrap alert at the top of the page and a dropdown component at the top right corner.
	//Everything still works even after we changed the way how we include bootstrap css into a project.
	//So in this video we have learnt the second way of importing bootstrap css using webpack.


Section 13:  Using FontAwesome with Webpack
	//In this video we will learn how to use font awesome together with web pack.
	//For those of you who never have heard about font awesome. fontawesome.com
	//This is one of the most popular icon fonts on the Web.
	//These icons are used by hundreds and even thousands of Web sites.
	//Traditional way of including the font awesome into your Website is to add a cdn link inside the head.
	//One of the students asked me recently if it's possible to install font-awesome as NPM package 
		and work with it the same way as it has other dependencies.
	//The answer is yes and in this video I will show you how 
	//In the latest version of fontawesome they introduced svg javascript framework 
	//using this framework is the recommended way to integrate fontawesome with web pack
	//First we need to install four different npm packages.
	//first package fontawesome-svg-core
	//fontawesome-svg-core provides the core functionality of svg javascript framework.
	//The other three npm packages include font awesome icons.
		free-brands-svg-icons
		free-solid-svg-icons
		free-regular-svg-icons
	//Now we need to go to the editor and import this packages 
	//I will import them inside index.js
	//I will import fontawesome-svg-core 
	//library object allows us to specify which icons we want to use 
	//we will use DOM object to replace any existing I fix these svg 
	//as I already said we don't have to import all possible icons from fontawesome.
	//We can specify only those icons which we need in our project 
	//I will import on one icon for now which is faspinner and I will add this icon to the library
	//I have imported only one package which contains solid svg icons because I don't need the other two packages.
	//Obviously if you need an icon from a regular svg icons or light icons you would need to import those packages as well.
	//Now we can add this icon to our page.
	//I will go to the page template and here I will add.
	//I am specifying three classes here 
	//fas means that we want to use an icon fromawesome solid icons 
	//fa-spinner specifies the name of the icon 
	//fa-spin fails the browser that this icon should rotate.
	//There are five thousand different icons included in font-awesome library and more than 1000 of them is free of charge.
	//By the way we can still use <i> tags in html.
	//fontawesome library will replace this text these svg icons but for this to happen we need to add one more line to our javascript code.
	//I will go to index.js and here you remember the imported DOM object.
	//Now I will use it.
	//DOM object has watch() method and we will invoke this method 
	//Then this method will replace any existing i text with svg.
	//What's more it will set up an observer to continue doing this If it don't changes 
	//for example if  we generate some font awesome icons dynamically and add them later to the document object model 
		they will also be replaced by svg.
	//Now let's go to the terminal and run the build process and I will start the application.
	//Let's go to the browser and have a look at the new loading icon.
	//And you see this a loading icon right here in the top left corner.
	//In this video if I've learned how to use font awesome together with web pack.




Section 14:  ESLint
	//In this video we'll talk about linter in general and ESLint in particular.
	//This topic is not connected directly to webpack. 
	//You can use ESLin even if you don't use Webpack in your project.
	//Therefore this video is optional and is not required in order to understand how webpack works.
	//However, I think that the information presented in this video is useful for you if you plan to work on any javascript project. 
	//So what is a linter?
	//According to Wikipedia a linter refers to tools that analyze the source code to flag programming errors, bugs, stylistic errors, and suspicious 			constructs.
	//The term originates from a Unix utility that examined C language source code.
	//The term is now applied generically to tools that flag suspicious code in software written in any programming language.
	//Linters can warn you about syntax errors,
	//uses of undeclared variables, calls to deprecated functions, spacing and formatting conventions, and much more.
	//There are linters for almost every programming language.
	//But in this video we are going to talk about ESLint.
	//ESLint is an open source project that provides a pluggable linting utility for JavaScript.
	//It is highly configurable and you can optimize it for the specific needs of your project.
	//Iâll show you how to install ESLint for this project associated with this course. 
	//If you want to repeat all the steps on your local computer, you would need to clone this repository.
	//And check out the branch which is called starting-point-for-use-cases.
	//So let me show you how to configure linting for this project.
	//First, we need to install ESLint.
	//This will install ESLint into node_modules folder of this project.
	//Now let's go to the editor and add an NPM script that will run ESLint for us. 
	//I will go to the package.json.
	//And here we have the list of scripts. 
	//I will add a new script which we'll call lint.
	//And here I will just specify the eslint . without any additional options.
	//So now we need to create a configuration file for ESLint.
	//This file is called .eslintrc and it uses json format. 
	//So let me create this file in the root directory of the project
	//Here in this file we can specify the rules, and according to these rules ESLint will inspect our code.
	//All ESLint are configurable, and on this page you can see a list of all the rules. 
		eslint.org/docs/rules
	//As you can see the list of rules is quite big.
	//It's quite hard to specify each and every rule with its specific configuration.
	//However, if you want to do that, it's possible. 
	//If you look at this list you will notice that some rules have checkmarks. 
	//These rules are widely used and they check the most common problems. 
	//They are so common that there is a shortcut in order to apply them all.
	//And this requires only one line of code. 
	//So here, inside the ESLint configuration file, I will add âextendsâ:  âeslint:recommendedâ. 
	//And this line tells ESLint to apply only the rules with checkmarks that we have seen just now.
	//But this is not all we need.
	//By default ESLint checks javascript code against Ecmascript 5 standard.
 	//However we use Ecmascript 6 in this project. 
	//That requires us to configure a couple more options inside ESLint configuration file.
	//So below this line we need to specify parser options.
	//And here we can specify the Ecmascript version and we will put 6 here.
	//And beside that we need to specify sourceType module.
	//So the sourceType allows us to use Ecmascript 6 modules. 
	//Otherwise ESLint would complain about import and export keywords.
	//If we run ESLint now, we will see a bunch of errors related to require function and document variable.
	//We need to teach ESLint that it should not complain about require function inside the webpack configuration files. 
	//Because the require function is defined when you run our build from the terminal using node js.
	//For this we need to tell ESLint that we are using node js environment.
	//Here we can specify env option and inside we can say that we are using a node environment.
	//So now ESLint will know that require function is defined and it will not complain about it anymore.
	//We also need to tell you need to not complain when it finds document variable inside our components
		because that code will be executed in the browser environment. 
	//And inside of the browser environment we have a document variable defined. 
	//So here we will also specify that we are using browser environment.
	//There is one more thing.
	//If you remember, we are using class properties in our project which is not part of official ecmascript specification yet.
	//ESLint will complain about it as well.
	//This line here refers to class properties.
	//So in order to fix this we need to use another parser for ESLint which is called babel-eslint.
	//First we need to install this parser.
	//Now we can add it to the eslint configuration file.
	//Here we just specify parser babel-eslint.
	//If we run eslint now, it will not complain about class properties anymore.
	//So now the only thing that is left is errors about the console.log statements that we have throughout the project.
	//These errors In order to remove this errors, we need to configure one more rule that checks for a console.log statements.
	//This rule is called no-console. 
	//By default eslint:recommended thing includes the rule that does not allow us to use console. log statements, 
	//but for the purpose of this project we need them.
	//So we need to override this rule.
	//All the rules are specified inside the rules object
	//And here we can say that no-console rule should be turned off.
	//So zero here means that this rule is turned off. 
	//If we run eslint in the terminal now, we will see that there are no complaints anymore.
	//So far every time we needed to check our code for linting errors, we went to a terminal and ran a command there.
	//But there is a way to setup linter inside the editor, so we can see the errors right away, without going to the terminal.
	//For every editor I know there is a plugin for eslint.
	//Since we are using Atom in this course, I'll show you how to install eslint for Atom.
	//First, we need to go to the Atom preferences.
	//And here we need to go to the tab called install. 
	//We need to install two packages here.
	//First one is called linter.
	//And I already have this package installed. 
	//And the second package is called linter-eslint.
	//I have this package as well.
	//Okay so these packages are installed. 
	//So let's check how this works.
	//I will go to hello-world-button.js file and intentionally make an error somewhere in the code.
	//So let's say we made a mistake, like a small typo, and instead of button we wrote batton. 
	//And immediately you can see a red circle to the left.
	//If I hover my mouse on this circle,I will see a message saying "batton is not defined". 
	//In general, code linting is the process of static code analysis that can help you discover bugs early on in the development process.
	//It can help you avoid spending half an hour of your time debugging production code just to find out that there is a typo in the name of the variable or something like that. 	//Of course, eslint cannot find a more complex bugs related to the business logic of your application. 
	//But at least it helps you to avoid dummy mistakes.
	//There is actually one more area where eslint can be applied.
	//eslint can help your team to define and follow a common coding standards which will make your project look like it was written by a single person.
	//I saw several teams using eslint specifically for this purpose.

Section 15: Summary
	//I hope you enjoyed this course and learn a lot of new things for yourself.
	//Let's do a quick recap of what we have done so far.
	//First, we created a small application with only two JavaScript files.
	//Then we integrate webpack into our application.
	//Then we looked at webpack loaders and learned how to import images and lots of other stuff into our application.
	//We also have seen how we can use latest cutting edge JavaScript features in our applications, even though they are not implemented in all major browsers.
	//After that, if you looked at several other plugins and know how to extract css	 into a separate bundle and how to generate each HTML files, 
	//we talked about browser creation and how webpack can help us with that.
	//Then we talked about the difference between production and development build and optimized, our configurations for these use cases.
	//We also talked about multipage applications and how we can handle common dependencies between several pages.
	//Finally, we learned how to integrate ExpressJS framework, both for single applications and for multipage applications.
	//It was a nice journey and we had a little fun together.
	//I hope you enjoyed watching this course as much as I enjoyed creating it.
	//Have a nice day and a happy life.
	




























	
	
	
	
	
	
	
	
	
